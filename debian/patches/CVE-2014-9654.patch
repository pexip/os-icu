Description: fix denial of service via incorrect pattern size limits
Origin: backport, http://bugs.icu-project.org/trac/changeset/31233
Origin: backport, http://bugs.icu-project.org/trac/changeset/36801
Bug: http://bugs.icu-project.org/trac/ticket/11371
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=776719

Index: icu-4.8.1.1/source/common/unicode/utypes.h
===================================================================
--- icu-4.8.1.1.orig/source/common/unicode/utypes.h	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/common/unicode/utypes.h	2015-03-02 08:20:03.441220865 -0500
@@ -810,6 +810,7 @@
     U_REGEX_STACK_OVERFLOW,               /**< Regular expression backtrack stack overflow.       */
     U_REGEX_TIME_OUT,                     /**< Maximum allowed match time exceeded                */
     U_REGEX_STOPPED_BY_CALLER,            /**< Matching operation aborted by user callback fn.    */
+    U_REGEX_PATTERN_TOO_BIG,              /**< Pattern exceeds limits on size or complexity.   @draft ICU 55   */
     U_REGEX_ERROR_LIMIT,                  /**< This must always be the last value to indicate the limit for regexp errors */
 
     /*
Index: icu-4.8.1.1/source/common/utypes.c
===================================================================
--- icu-4.8.1.1.orig/source/common/utypes.c	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/common/utypes.c	2015-03-02 08:20:03.441220865 -0500
@@ -165,7 +165,8 @@
     "U_REGEX_INVALID_RANGE",
     "U_REGEX_STACK_OVERFLOW",
     "U_REGEX_TIME_OUT",
-    "U_REGEX_STOPPED_BY_CALLER"
+    "U_REGEX_STOPPED_BY_CALLER",
+    "U_REGEX_PATTERN_TOO_BIG"
 };
 
 static const char * const
Index: icu-4.8.1.1/source/i18n/regexcmp.cpp
===================================================================
--- icu-4.8.1.1.orig/source/i18n/regexcmp.cpp	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/regexcmp.cpp	2015-03-02 08:20:03.441220865 -0500
@@ -69,7 +69,6 @@
 
     fMatchOpenParen   = -1;
     fMatchCloseParen  = -1;
-    fStringOpStart    = -1;
 
     if (U_SUCCESS(status) && U_FAILURE(rxp->fDeferredStatus)) {
         status = rxp->fDeferredStatus;
@@ -294,7 +293,7 @@
     //   present in the saved state:  the input string position (int64_t) and
     //   the position in the compiled pattern.
     //
-    fRXPat->fFrameSize+=RESTACKFRAME_HDRCOUNT;
+    allocateStackData(RESTACKFRAME_HDRCOUNT);
 
     //
     // Optimization pass 1: NOPs, back-references, and case-folding
@@ -360,9 +359,9 @@
         //                    the start of an ( grouping.
         //4   NOP             Resreved, will be replaced by a save if there are
         //                    OR | operators at the top level
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_STATE_SAVE, 2), *fStatus);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_JMP,  3), *fStatus);
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_FAIL, 0), *fStatus);
+        appendOp(URX_STATE_SAVE, 2);
+        appendOp(URX_JMP,  3);
+        appendOp(URX_FAIL, 0);
 
         // Standard open nonCapture paren action emits the two NOPs and
         //   sets up the paren stack frame.
@@ -385,7 +384,7 @@
         }
 
         // add the END operation to the compiled pattern.
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_END, 0), *fStatus);
+        appendOp(URX_END, 0);
 
         // Terminate the pattern compilation state machine.
         returnVal = FALSE;
@@ -396,6 +395,9 @@
     case doOrOperator:
         // Scanning a '|', as in (A|B)
         {
+            // Generate code for any pending literals preceding the '|'
+            fixLiterals(FALSE);
+
             // Insert a SAVE operation at the start of the pattern section preceding
             //   this OR at this level.  This SAVE will branch the match forward
             //   to the right hand side of the OR in the event that the left hand
@@ -404,14 +406,13 @@
             int32_t savePosition = fParenStack.popi();
             int32_t op = (int32_t)fRXPat->fCompiledPat->elementAti(savePosition);
             U_ASSERT(URX_TYPE(op) == URX_NOP);  // original contents of reserved location
-            op = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+1);
+            op = buildOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+1);
             fRXPat->fCompiledPat->setElementAt(op, savePosition);
 
             // Append an JMP operation into the compiled pattern.  The operand for
             //  the JMP will eventually be the location following the ')' for the
             //  group.  This will be patched in later, when the ')' is encountered.
-            op = URX_BUILD(URX_JMP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_JMP, 0);
 
             // Push the position of the newly added JMP op onto the parentheses stack.
             // This registers if for fixup when this block's close paren is encountered.
@@ -420,7 +421,7 @@
             // Append a NOP to the compiled pattern.  This is the slot reserved
             //   for a SAVE in the event that there is yet another '|' following
             //   this one.
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            appendOp(URX_NOP, 0);
             fParenStack.push(fRXPat->fCompiledPat->size()-1, *fStatus);
         }
         break;
@@ -445,12 +446,11 @@
         //      encountered.  This will be promoted to a completed capture when (and if) the corresponding
         //      END_CAPTURE is encountered.
         {
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            int32_t  varsLoc    = fRXPat->fFrameSize;    // Reserve three slots in match stack frame.
-            fRXPat->fFrameSize += 3;
-            int32_t  cop        = URX_BUILD(URX_START_CAPTURE, varsLoc);
-            fRXPat->fCompiledPat->addElement(cop, *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            fixLiterals();
+            appendOp(URX_NOP, 0);
+            int32_t  varsLoc = allocateStackData(3);    // Reserve three slots in match stack frame.
+            appendOp(URX_START_CAPTURE, varsLoc);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs.  Depending on what follows in the pattern, the
@@ -474,8 +474,9 @@
         //      - NOP, which may later be replaced by a save-state if there
         //             is an '|' alternation within the parens.
         {
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            fixLiterals();
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs.
@@ -496,12 +497,11 @@
         //      - NOP, which may later be replaced by a save-state if there
         //             is an '|' alternation within the parens.
         {
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            int32_t  varLoc    = fRXPat->fDataSize;    // Reserve a data location for saving the
-            fRXPat->fDataSize += 1;                    //  state stack ptr.
-            int32_t  stoOp     = URX_BUILD(URX_STO_SP, varLoc);
-            fRXPat->fCompiledPat->addElement(stoOp, *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            fixLiterals();
+            appendOp(URX_NOP, 0);
+            int32_t  varLoc = allocateData(1);    // Reserve a data location for saving the state stack ptr.
+            appendOp(URX_STO_SP, varLoc);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs.  Depending on what follows in the pattern, the
@@ -543,26 +543,15 @@
         //
         //  Two data slots are reserved, for saving the stack ptr and the input position.
         {
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 2;
-            int32_t op = URX_BUILD(URX_LA_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+ 2);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_JMP, fRXPat->fCompiledPat->size()+ 3);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            
-            op = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_BACKTRACK, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            fixLiterals();
+            int32_t dataLoc = allocateData(2);
+            appendOp(URX_LA_START, dataLoc);
+            appendOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+ 2);
+            appendOp(URX_JMP, fRXPat->fCompiledPat->size()+ 3);
+            appendOp(URX_LA_END, dataLoc);
+            appendOp(URX_BACKTRACK, 0);
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the NOPs.
@@ -586,16 +575,11 @@
         //    7.    END_LA                // Restore match region, in case look-ahead was using
         //                                        an alternate (transparent) region.
         {
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 2;
-            int32_t op = URX_BUILD(URX_LA_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_STATE_SAVE, 0);    // dest address will be patched later.
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            fixLiterals();
+            int32_t dataLoc = allocateData(2);
+            appendOp(URX_LA_START, dataLoc);
+            appendOp(URX_STATE_SAVE, 0);    // dest address will be patched later.
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the StateSave and NOP.
@@ -629,24 +613,23 @@
             //              2:    Start index of match current match attempt.
             //              3:    Original Input String len.
 
+            // Generate match code for any pending literals.
+            fixLiterals();
+
             // Allocate data space
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 4;
+            int32_t dataLoc = allocateData(4);
 
             // Emit URX_LB_START
-            int32_t op = URX_BUILD(URX_LB_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_START, dataLoc);
 
             // Emit URX_LB_CONT
-            op = URX_BUILD(URX_LB_CONT, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MinMatchLength.  To be filled later.
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MaxMatchLength.  To be filled later.
-
-            // Emit the NOP
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_CONT, dataLoc);
+            appendOp(URX_RESERVED_OP, 0);    // MinMatchLength.  To be filled later.
+            appendOp(URX_RESERVED_OP, 0);    // MaxMatchLength.  To be filled later.
+
+            // Emit the NOPs
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the URX_LB_CONT and the NOP.
@@ -682,25 +665,24 @@
             //              2:    Start index of match current match attempt.
             //              3:    Original Input String len.
 
+            // Generate match code for any pending literals.
+            fixLiterals();
+
             // Allocate data space
-            int32_t dataLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize += 4;
+            int32_t dataLoc = allocateData(4);
 
             // Emit URX_LB_START
-            int32_t op = URX_BUILD(URX_LB_START, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_START, dataLoc);
 
             // Emit URX_LBN_CONT
-            op = URX_BUILD(URX_LBN_CONT, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MinMatchLength.  To be filled later.
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // MaxMatchLength.  To be filled later.
-            fRXPat->fCompiledPat->addElement(0,  *fStatus);    // Continue Loc.    To be filled later.
-
-            // Emit the NOP
-            op = URX_BUILD(URX_NOP, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LBN_CONT, dataLoc);
+            appendOp(URX_RESERVED_OP, 0);    // MinMatchLength.  To be filled later.
+            appendOp(URX_RESERVED_OP, 0);    // MaxMatchLength.  To be filled later.
+            appendOp(URX_RESERVED_OP, 0);    // Continue Loc.    To be filled later.
+
+            // Emit the NOPs
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the URX_LB_CONT and the NOP.
@@ -770,12 +752,9 @@
 
                 if (URX_TYPE(repeatedOp) == URX_SETREF) {
                     // Emit optimized code for [char set]+
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_SR_I, URX_VAL(repeatedOp));
-                    fRXPat->fCompiledPat->addElement(loopOpI, *fStatus);
-                    frameLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, frameLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    appendOp(URX_LOOP_SR_I, URX_VAL(repeatedOp));
+                    frameLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, frameLoc);
                     break;
                 }
 
@@ -783,7 +762,7 @@
                     URX_TYPE(repeatedOp) == URX_DOTANY_ALL ||
                     URX_TYPE(repeatedOp) == URX_DOTANY_UNIX) {
                     // Emit Optimized code for .+ operations.
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_DOT_I, 0);
+                    int32_t loopOpI = buildOp(URX_LOOP_DOT_I, 0);
                     if (URX_TYPE(repeatedOp) == URX_DOTANY_ALL) {
                         // URX_LOOP_DOT_I operand is a flag indicating ". matches any" mode.
                         loopOpI |= 1;
@@ -791,11 +770,9 @@
                     if (fModeFlags & UREGEX_UNIX_LINES) {
                         loopOpI |= 2;
                     }
-                    fRXPat->fCompiledPat->addElement(loopOpI, *fStatus);
-                    frameLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, frameLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    appendOp(loopOpI);
+                    frameLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, frameLoc);
                     break;
                 }
 
@@ -809,18 +786,15 @@
                 // Zero length match is possible.
                 // Emit the code sequence that can handle it.
                 insertOp(topLoc);
-                frameLoc =  fRXPat->fFrameSize;
-                fRXPat->fFrameSize++;
+                frameLoc = allocateStackData(1);
 
-                int32_t op = URX_BUILD(URX_STO_INP_LOC, frameLoc);
+                int32_t op = buildOp(URX_STO_INP_LOC, frameLoc);
                 fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
-                op = URX_BUILD(URX_JMP_SAV_X, topLoc+1);
-                fRXPat->fCompiledPat->addElement(op, *fStatus);
+                appendOp(URX_JMP_SAV_X, topLoc+1);
             } else {
                 // Simpler code when the repeated body must match something non-empty
-                int32_t  jmpOp  = URX_BUILD(URX_JMP_SAV, topLoc);
-                fRXPat->fCompiledPat->addElement(jmpOp, *fStatus);
+                appendOp(URX_JMP_SAV, topLoc);
             }
         }
         break;
@@ -832,8 +806,7 @@
         //     3.   ...
         {
             int32_t topLoc      = blockTopLoc(FALSE);
-            int32_t saveStateOp = URX_BUILD(URX_STATE_SAVE, topLoc);
-            fRXPat->fCompiledPat->addElement(saveStateOp, *fStatus);
+            appendOp(URX_STATE_SAVE, topLoc);
         }
         break;
 
@@ -847,7 +820,7 @@
         // Insert the state save into the compiled pattern, and we're done.
         {
             int32_t   saveStateLoc = blockTopLoc(TRUE);
-            int32_t   saveStateOp  = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size());
+            int32_t   saveStateOp  = buildOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size());
             fRXPat->fCompiledPat->setElementAt(saveStateOp, saveStateLoc);
         }
         break;
@@ -866,14 +839,12 @@
             int32_t  jmp1_loc = blockTopLoc(TRUE);
             int32_t  jmp2_loc = fRXPat->fCompiledPat->size();
 
-            int32_t  jmp1_op  = URX_BUILD(URX_JMP, jmp2_loc+1);
+            int32_t  jmp1_op  = buildOp(URX_JMP, jmp2_loc+1);
             fRXPat->fCompiledPat->setElementAt(jmp1_op, jmp1_loc);
 
-            int32_t  jmp2_op  = URX_BUILD(URX_JMP, jmp2_loc+2);
-            fRXPat->fCompiledPat->addElement(jmp2_op, *fStatus);
+            appendOp(URX_JMP, jmp2_loc+2);
 
-            int32_t  save_op  = URX_BUILD(URX_STATE_SAVE, jmp1_loc+1);
-            fRXPat->fCompiledPat->addElement(save_op, *fStatus);
+            appendOp(URX_STATE_SAVE, jmp1_loc+1);
         }
         break;
 
@@ -913,12 +884,10 @@
 
                 if (URX_TYPE(repeatedOp) == URX_SETREF) {
                     // Emit optimized code for a [char set]*
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_SR_I, URX_VAL(repeatedOp));
+                    int32_t loopOpI = buildOp(URX_LOOP_SR_I, URX_VAL(repeatedOp));
                     fRXPat->fCompiledPat->setElementAt(loopOpI, topLoc);
-                    dataLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, dataLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    dataLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, dataLoc);
                     break;
                 }
 
@@ -926,7 +895,7 @@
                     URX_TYPE(repeatedOp) == URX_DOTANY_ALL ||
                     URX_TYPE(repeatedOp) == URX_DOTANY_UNIX) {
                     // Emit Optimized code for .* operations.
-                    int32_t loopOpI = URX_BUILD(URX_LOOP_DOT_I, 0);
+                    int32_t loopOpI = buildOp(URX_LOOP_DOT_I, 0);
                     if (URX_TYPE(repeatedOp) == URX_DOTANY_ALL) {
                         // URX_LOOP_DOT_I operand is a flag indicating . matches any mode.
                         loopOpI |= 1;
@@ -935,10 +904,8 @@
                         loopOpI |= 2;
                     }
                     fRXPat->fCompiledPat->setElementAt(loopOpI, topLoc);
-                    dataLoc = fRXPat->fFrameSize;
-                    fRXPat->fFrameSize++;
-                    int32_t loopOpC = URX_BUILD(URX_LOOP_C, dataLoc);
-                    fRXPat->fCompiledPat->addElement(loopOpC, *fStatus);
+                    dataLoc = allocateStackData(1);
+                    appendOp(URX_LOOP_C, dataLoc);
                     break;
                 }
             }
@@ -947,30 +914,29 @@
             // The optimizations did not apply.
 
             int32_t   saveStateLoc = blockTopLoc(TRUE);
-            int32_t   jmpOp        = URX_BUILD(URX_JMP_SAV, saveStateLoc+1);
+            int32_t   jmpOp        = buildOp(URX_JMP_SAV, saveStateLoc+1);
 
             // Check for minimum match length of zero, which requires
             //    extra loop-breaking code.
             if (minMatchLength(saveStateLoc, fRXPat->fCompiledPat->size()-1) == 0) {
                 insertOp(saveStateLoc);
-                dataLoc =  fRXPat->fFrameSize;
-                fRXPat->fFrameSize++;
+                dataLoc = allocateStackData(1);
 
-                int32_t op = URX_BUILD(URX_STO_INP_LOC, dataLoc);
+                int32_t op = buildOp(URX_STO_INP_LOC, dataLoc);
                 fRXPat->fCompiledPat->setElementAt(op, saveStateLoc+1);
-                jmpOp      = URX_BUILD(URX_JMP_SAV_X, saveStateLoc+2);
+                jmpOp      = buildOp(URX_JMP_SAV_X, saveStateLoc+2);
             }
 
             // Locate the position in the compiled pattern where the match will continue
             //   after completing the *.   (4 or 5 in the comment above)
             int32_t continueLoc = fRXPat->fCompiledPat->size()+1;
 
-            // Put together the save state op store it into the compiled code.
-            int32_t saveStateOp = URX_BUILD(URX_STATE_SAVE, continueLoc);
+            // Put together the save state op and store it into the compiled code.
+            int32_t saveStateOp = buildOp(URX_STATE_SAVE, continueLoc);
             fRXPat->fCompiledPat->setElementAt(saveStateOp, saveStateLoc);
 
             // Append the URX_JMP_SAV or URX_JMPX operation to the compiled pattern.
-            fRXPat->fCompiledPat->addElement(jmpOp, *fStatus);
+            appendOp(jmpOp);
         }
         break;
 
@@ -984,10 +950,9 @@
         {
             int32_t     jmpLoc  = blockTopLoc(TRUE);                   // loc  1.
             int32_t     saveLoc = fRXPat->fCompiledPat->size();        // loc  3.
-            int32_t     jmpOp   = URX_BUILD(URX_JMP, saveLoc);
-            int32_t     stateSaveOp = URX_BUILD(URX_STATE_SAVE, jmpLoc+1);
+            int32_t     jmpOp   = buildOp(URX_JMP, saveLoc);
             fRXPat->fCompiledPat->setElementAt(jmpOp, jmpLoc);
-            fRXPat->fCompiledPat->addElement(stateSaveOp, *fStatus);
+            appendOp(URX_STATE_SAVE, jmpLoc+1);
         }
         break;
 
@@ -1056,9 +1021,9 @@
 
             // First the STO_SP before the start of the loop
             insertOp(topLoc);
-            int32_t  varLoc    = fRXPat->fDataSize;    // Reserve a data location for saving the
-            fRXPat->fDataSize += 1;                    //  state stack ptr.
-            int32_t  op        = URX_BUILD(URX_STO_SP, varLoc);
+
+            int32_t  varLoc = allocateData(1);   // Reserve a data location for saving the
+            int32_t  op     = buildOp(URX_STO_SP, varLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             int32_t loopOp = (int32_t)fRXPat->fCompiledPat->popi();
@@ -1067,8 +1032,7 @@
             fRXPat->fCompiledPat->push(loopOp, *fStatus);
 
             // Then the LD_SP after the end of the loop
-            op = URX_BUILD(URX_LD_SP, varLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, varLoc);
         }
 
         break;
@@ -1103,52 +1067,50 @@
     case doDotAny:
         // scanned a ".",  match any single character.
         {
-            int32_t   op;
+            fixLiterals(FALSE);
             if (fModeFlags & UREGEX_DOTALL) {
-                op = URX_BUILD(URX_DOTANY_ALL, 0);
+                appendOp(URX_DOTANY_ALL, 0);
             } else if (fModeFlags & UREGEX_UNIX_LINES) {
-                op = URX_BUILD(URX_DOTANY_UNIX, 0);
+                appendOp(URX_DOTANY_UNIX, 0);
             } else {
-                op = URX_BUILD(URX_DOTANY, 0);
+                appendOp(URX_DOTANY, 0);
             }
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
         }
         break;
 
     case doCaret:
         {
-            int32_t op = 0;
+            fixLiterals(FALSE);
             if (       (fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_CARET;
+                appendOp(URX_CARET, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_CARET_M;
+                appendOp(URX_CARET_M, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_CARET;   // Only testing true start of input. 
+                appendOp(URX_CARET, 0);   // Only testing true start of input.
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_CARET_M_UNIX;
+                appendOp(URX_CARET_M_UNIX, 0);
             }
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 0), *fStatus);
         }
         break;
 
     case doDollar:
         {
-            int32_t op = 0;
+            fixLiterals(FALSE);
             if (       (fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_DOLLAR;
+                appendOp(URX_DOLLAR, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) == 0) {
-                op = URX_DOLLAR_M;
+                appendOp(URX_DOLLAR_M, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) == 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_DOLLAR_D;
+                appendOp(URX_DOLLAR_D, 0);
             } else if ((fModeFlags & UREGEX_MULTILINE) != 0 && (fModeFlags & UREGEX_UNIX_LINES) != 0) {
-                op = URX_DOLLAR_MD;
+                appendOp(URX_DOLLAR_MD, 0);
             }
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 0), *fStatus);
         }
         break;
 
     case doBackslashA:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_CARET, 0), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_CARET, 0);
         break;
 
     case doBackslashB:
@@ -1158,8 +1120,9 @@
                 error(U_UNSUPPORTED_ERROR);
             }
             #endif
+            fixLiterals(FALSE);
             int32_t op = (fModeFlags & UREGEX_UWORD)? URX_BACKSLASH_BU : URX_BACKSLASH_B;
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 1), *fStatus);
+            appendOp(op, 1);
         }
         break;
 
@@ -1170,54 +1133,61 @@
                 error(U_UNSUPPORTED_ERROR);
             }
             #endif
+            fixLiterals(FALSE);
             int32_t op = (fModeFlags & UREGEX_UWORD)? URX_BACKSLASH_BU : URX_BACKSLASH_B;
-            fRXPat->fCompiledPat->addElement(URX_BUILD(op, 0), *fStatus);
+            appendOp(op, 0);
         }
         break;
 
     case doBackslashD:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_D, 1), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_BACKSLASH_D, 1);
         break;
 
     case doBackslashd:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_D, 0), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_BACKSLASH_D, 0);
         break;
 
     case doBackslashG:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_G, 0), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_BACKSLASH_G, 0);
         break;
 
     case doBackslashS:
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STAT_SETREF_N, URX_ISSPACE_SET), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_STAT_SETREF_N, URX_ISSPACE_SET);
         break;
 
     case doBackslashs:
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STATIC_SETREF, URX_ISSPACE_SET), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_STATIC_SETREF, URX_ISSPACE_SET);
         break;
 
     case doBackslashW:
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STAT_SETREF_N, URX_ISWORD_SET), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_STAT_SETREF_N, URX_ISWORD_SET);
         break;
 
     case doBackslashw:
-        fRXPat->fCompiledPat->addElement(
-            URX_BUILD(URX_STATIC_SETREF, URX_ISWORD_SET), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_STATIC_SETREF, URX_ISWORD_SET);
         break;
 
     case doBackslashX:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_X, 0), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_BACKSLASH_X, 0);
         break;
 
 
     case doBackslashZ:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_DOLLAR, 0), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_DOLLAR, 0);
         break;
 
     case doBackslashz:
-        fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKSLASH_Z, 0), *fStatus);
+        fixLiterals(FALSE);
+        appendOp(URX_BACKSLASH_Z, 0);
         break;
 
     case doEscapeError:
@@ -1225,11 +1195,13 @@
         break;
 
     case doExit:
+        fixLiterals(FALSE);
         returnVal = FALSE;
         break;
 
     case doProperty:
         {
+            fixLiterals(FALSE);
             UnicodeSet *theSet = scanProp();
             compileSet(theSet);
         }
@@ -1272,14 +1244,14 @@
             // Because capture groups can be forward-referenced by back-references,
             //  we fill the operand with the capture group number.  At the end
             //  of compilation, it will be changed to the variable's location.
-            U_ASSERT(groupNum > 0);
-            int32_t  op;
+            U_ASSERT(groupNum > 0);  // Shouldn't happen.  '\0' begins an octal escape sequence,
+                                     //    and shouldn't enter this code path at all.
+            fixLiterals(FALSE);
             if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
-                op = URX_BUILD(URX_BACKREF_I, groupNum);
+                appendOp(URX_BACKREF_I, groupNum);
             } else {
-                op = URX_BUILD(URX_BACKREF, groupNum);
+                appendOp(URX_BACKREF, groupNum);
             }
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
         }
         break;
 
@@ -1300,22 +1272,18 @@
         {
             // Emit the STO_SP
             int32_t   topLoc = blockTopLoc(TRUE);
-            int32_t   stoLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize++;       // Reserve the data location for storing save stack ptr.
-            int32_t   op     = URX_BUILD(URX_STO_SP, stoLoc);
+            int32_t   stoLoc = allocateData(1);  // Reserve the data location for storing save stack ptr.
+            int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             // Emit the STATE_SAVE
-            op = URX_BUILD(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+2);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_STATE_SAVE, fRXPat->fCompiledPat->size()+2);
 
             // Emit the JMP
-            op = URX_BUILD(URX_JMP, topLoc+1);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_JMP, topLoc+1);
 
             // Emit the LD_SP
-            op = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -1335,23 +1303,20 @@
             insertOp(topLoc);
 
             // emit   STO_SP     loc
-            int32_t   stoLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize++;       // Reserve the data location for storing save stack ptr.
-            int32_t   op     = URX_BUILD(URX_STO_SP, stoLoc);
+            int32_t   stoLoc = allocateData(1);    // Reserve the data location for storing save stack ptr.
+            int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             // Emit the SAVE_STATE   5
             int32_t L7 = fRXPat->fCompiledPat->size()+1;
-            op = URX_BUILD(URX_STATE_SAVE, L7);
+            op = buildOp(URX_STATE_SAVE, L7);
             fRXPat->fCompiledPat->setElementAt(op, topLoc+1);
 
             // Append the JMP operation.
-            op = URX_BUILD(URX_JMP, topLoc+1);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_JMP, topLoc+1);
 
             // Emit the LD_SP       loc
-            op = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -1370,19 +1335,17 @@
             insertOp(topLoc);
 
             // Emit the STO_SP
-            int32_t   stoLoc = fRXPat->fDataSize;
-            fRXPat->fDataSize++;       // Reserve the data location for storing save stack ptr.
-            int32_t   op     = URX_BUILD(URX_STO_SP, stoLoc);
+            int32_t   stoLoc = allocateData(1);   // Reserve the data location for storing save stack ptr.
+            int32_t   op     = buildOp(URX_STO_SP, stoLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc);
 
             // Emit the SAVE_STATE
             int32_t   continueLoc = fRXPat->fCompiledPat->size()+1;
-            op = URX_BUILD(URX_STATE_SAVE, continueLoc);
+            op = buildOp(URX_STATE_SAVE, continueLoc);
             fRXPat->fCompiledPat->setElementAt(op, topLoc+1);
 
             // Emit the LD_SP
-            op = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -1417,14 +1380,14 @@
         break;
 
     case doSetMatchMode:
+        // Emit code to match any pending literals, using the not-yet changed match mode.
+        fixLiterals();
+
         // We've got a (?i) or similar.  The match mode is being changed, but
         //   the change is not scoped to a parenthesized block.
         U_ASSERT(fNewModeFlags < 0);
         fModeFlags = fNewModeFlags;
 
-        // Prevent any string from spanning across the change of match mode.
-        //   Otherwise the pattern "abc(?i)def" would make a single string of "abcdef"
-        fixLiterals();
         break;
 
 
@@ -1438,8 +1401,9 @@
         //      - NOP, which may later be replaced by a save-state if there
         //             is an '|' alternation within the parens.
         {
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_NOP, 0), *fStatus);
+            fixLiterals(FALSE);
+            appendOp(URX_NOP, 0);
+            appendOp(URX_NOP, 0);
 
             // On the Parentheses stack, start a new frame and add the postions
             //   of the two NOPs (a normal non-capturing () frame, except for the
@@ -1533,6 +1497,7 @@
         }
 
     case doSetBegin:
+        fixLiterals(FALSE);
         fSetStack.push(new UnicodeSet(), *fStatus);
         fSetOpStack.push(setStart, *fStatus);
         if ((fModeFlags & UREGEX_CASE_INSENSITIVE) != 0) {
@@ -1734,7 +1699,6 @@
         break;
         }
 
-
     default:
         U_ASSERT(FALSE);
         error(U_REGEX_INTERNAL_ERROR);
@@ -1756,111 +1720,18 @@
 //                             or an escape sequence that reduces to a character.
 //                         Add it to the string containing all literal chars/strings from
 //                             the pattern.
-//                         If we are in a pattern string already, add the new char to it.
-//                         If we aren't in a pattern string, begin one now.
 //
 //------------------------------------------------------------------------------
 void RegexCompile::literalChar(UChar32 c)  {
-    int32_t           op;            // An operation in the compiled pattern.
-    int32_t           opType;
-    int32_t           patternLoc;   // A position in the compiled pattern.
-    int32_t           stringLen;
-
-
-    // If the last thing compiled into the pattern was not a literal char,
-    //   force this new literal char to begin a new string, and not append to the previous.
-    op     = (int32_t)fRXPat->fCompiledPat->lastElementi();
-    opType = URX_TYPE(op);
-    if (!(opType == URX_STRING_LEN || opType == URX_ONECHAR || opType == URX_ONECHAR_I)) {
-        fixLiterals();
-    }
-
-    if (fStringOpStart == -1) {
-        // First char of a string in the pattern.
-        // Emit a OneChar op into the compiled pattern.
-        emitONE_CHAR(c);
-        
-        // Mark that we might actually be starting a string here
-        fStringOpStart = fRXPat->fLiteralText.length();
-        return;
-    }
-
-    op     = (int32_t)fRXPat->fCompiledPat->lastElementi();
-    opType = URX_TYPE(op);
-    U_ASSERT(opType == URX_ONECHAR || opType == URX_ONECHAR_I || opType == URX_STRING_LEN);
-
-    // If the most recently emitted op is a URX_ONECHAR,
-    if (opType == URX_ONECHAR || opType == URX_ONECHAR_I) {
-        if (U16_IS_TRAIL(c) && U16_IS_LEAD(URX_VAL(op))) {
-            // The most recently emitted op is a ONECHAR that was the first half
-            //   of a surrogate pair.  Update the ONECHAR's operand to be the
-            //   supplementary code point resulting from both halves of the pair.
-            c = U16_GET_SUPPLEMENTARY(URX_VAL(op), c);
-            op = URX_BUILD(opType, c);
-            patternLoc = fRXPat->fCompiledPat->size() - 1;
-            fRXPat->fCompiledPat->setElementAt(op, patternLoc);
-            return;
-        }
-        
-        // The most recently emitted op is a ONECHAR.
-        //  We've now received another adjacent char.  Change the ONECHAR op
-        //   to a string op.
-        fRXPat->fLiteralText.append(URX_VAL(op));
-
-        if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
-            op     = URX_BUILD(URX_STRING_I, fStringOpStart);
-        } else {
-            op     = URX_BUILD(URX_STRING, fStringOpStart);
-        }
-        patternLoc = fRXPat->fCompiledPat->size() - 1;
-        fRXPat->fCompiledPat->setElementAt(op, patternLoc);
-        op         = URX_BUILD(URX_STRING_LEN, 0);
-        fRXPat->fCompiledPat->addElement(op, *fStatus);
-    }
-    
-    // We are adding onto an existing string
-    fRXPat->fLiteralText.append(c);
-    
-    // The pattern contains a URX_SRING / URX_STRING_LEN.  Update the
-    //  string length to reflect the new char we just added to the string.
-    stringLen  = fRXPat->fLiteralText.length() - fStringOpStart;
-    op         = URX_BUILD(URX_STRING_LEN, stringLen);
-    patternLoc = fRXPat->fCompiledPat->size() - 1;
-    fRXPat->fCompiledPat->setElementAt(op, patternLoc);
-}
-
-
-
-//------------------------------------------------------------------------------
-//
-//    emitONE_CHAR         emit a ONE_CHAR op into the generated code.
-//                         Choose cased or uncased version, depending on the
-//                         match mode and whether the character itself is cased.
-//
-//------------------------------------------------------------------------------
-void RegexCompile::emitONE_CHAR(UChar32  c) {
-    int32_t op;
-    if ((fModeFlags & UREGEX_CASE_INSENSITIVE) &&
-        u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
-        // We have a cased character, and are in case insensitive matching mode.
-        //c  = u_foldCase(c, U_FOLD_CASE_DEFAULT);  // !!!: handled in stripNOPs() now
-        op = URX_BUILD(URX_ONECHAR_I, c);
-    } else {
-        // Uncased char, or case sensitive match mode.
-        //  Either way, just generate a literal compare of the char.
-        op = URX_BUILD(URX_ONECHAR, c);
-    }
-    fRXPat->fCompiledPat->addElement(op, *fStatus);
+    fLiteralChars.append(c);
 }
 
 
 //------------------------------------------------------------------------------
 //
 //    fixLiterals           When compiling something that can follow a literal
-//                          string in a pattern, we need to "fix" any preceding
-//                          string, which will cause any subsequent literals to
-//                          begin a new string, rather than appending to the
-//                          old one.
+//                          string in a pattern, emit the code to match the
+//                          accumulated literal string.
 //
 //                          Optionally, split the last char of the string off into
 //                          a single "ONE_CHAR" operation, so that quantifiers can
@@ -1869,68 +1740,122 @@
 //
 //------------------------------------------------------------------------------
 void    RegexCompile::fixLiterals(UBool split) {
-    int32_t  stringStart = fStringOpStart;    // start index of the current literal string
-    int32_t  op;                              // An op from/for the compiled pattern.
-    int32_t  opType;                          // An opcode type from the compiled pattern.
-    int32_t  stringLastCharIdx;
-    UChar32  lastChar;
-    int32_t  stringNextToLastCharIdx;
-    UChar32  nextToLastChar;
-    int32_t  stringLen;
 
-    fStringOpStart = -1;
-    if (!split) {
+    // If no literal characters have been scanned but not yet had code generated
+    //   for them, nothing needs to be done.
+    if (fLiteralChars.length() == 0) {
         return;
     }
 
-    // Split:  We need to  ensure that the last item in the compiled pattern does
-    //   not refer to a literal string of more than one char.  If it does,
-    //   separate the last char from the rest of the string.
-
-    // If the last operation from the compiled pattern is not a string,
-    //   nothing needs to be done
-    op     = (int32_t)fRXPat->fCompiledPat->lastElementi();
-    opType = URX_TYPE(op);
-    if (opType != URX_STRING_LEN) {
+    int32_t indexOfLastCodePoint = fLiteralChars.moveIndex32(fLiteralChars.length(), -1);
+    UChar32 lastCodePoint = fLiteralChars.char32At(indexOfLastCodePoint);
+
+    // Split:  We need to  ensure that the last item in the compiled pattern 
+    //     refers only to the last literal scanned in the pattern, so that
+    //     quantifiers (*, +, etc.) affect only it, and not a longer string.
+    //     Split before case folding for case insensitive matches.
+
+    if (split) {
+        fLiteralChars.truncate(indexOfLastCodePoint);
+        fixLiterals(FALSE);   // Recursive call, emit code to match the first part of the string.
+                              //  Note that the truncated literal string may be empty, in which case
+                              //  nothing will be emitted.
+
+        literalChar(lastCodePoint);  // Re-add the last code point as if it were a new literal.
+        fixLiterals(FALSE);          // Second recursive call, code for the final code point.
         return;
     }
-    stringLen = URX_VAL(op);
 
-    //
-    // Find the position of the last code point in the string  (might be a surrogate pair)
-    //
-    stringLastCharIdx = fRXPat->fLiteralText.length();
-    stringLastCharIdx = fRXPat->fLiteralText.moveIndex32(stringLastCharIdx, -1);
-    lastChar          = fRXPat->fLiteralText.char32At(stringLastCharIdx);
-
-    // The string should always be at least two code points long, meaning that there
-    //   should be something before the last char position that we just found.
-    U_ASSERT(stringLastCharIdx > stringStart);
-    stringNextToLastCharIdx = fRXPat->fLiteralText.moveIndex32(stringLastCharIdx, -1);
-    U_ASSERT(stringNextToLastCharIdx >= stringStart);
-    nextToLastChar          = fRXPat->fLiteralText.char32At(stringNextToLastCharIdx);
-
-    if (stringNextToLastCharIdx > stringStart) {
-        // The length of string remaining after removing one char is two or more.
-        // Leave the string in the compiled pattern, shorten it by one char,
-        //   and append a URX_ONECHAR op for the last char.
-        stringLen -= (fRXPat->fLiteralText.length() - stringLastCharIdx);
-        op = URX_BUILD(URX_STRING_LEN, stringLen);
-        fRXPat->fCompiledPat->setElementAt(op, fRXPat->fCompiledPat->size() -1);
-        emitONE_CHAR(lastChar);
+    // If we are doing case-insensitive matching, case fold the string.  This may expand
+    //   the string, e.g. the German sharp-s turns into "ss"
+    if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
+        fLiteralChars.foldCase();
+        indexOfLastCodePoint = fLiteralChars.moveIndex32(fLiteralChars.length(), -1);
+        lastCodePoint = fLiteralChars.char32At(indexOfLastCodePoint);
+    }
+
+    if (indexOfLastCodePoint == 0) {
+        // Single character, emit a URX_ONECHAR op to match it.
+        if ((fModeFlags & UREGEX_CASE_INSENSITIVE) && 
+                 u_hasBinaryProperty(lastCodePoint, UCHAR_CASE_SENSITIVE)) {
+            appendOp(URX_ONECHAR_I, lastCodePoint);
+        } else {
+            appendOp(URX_ONECHAR, lastCodePoint);
+        }
     } else {
-        // The original string consisted of exactly two characters.  Replace
-        // the existing compiled URX_STRING/URX_STRING_LEN ops with a pair
-        // of URX_ONECHARs.
-        fRXPat->fCompiledPat->setSize(fRXPat->fCompiledPat->size() -2);
-        emitONE_CHAR(nextToLastChar);
-        emitONE_CHAR(lastChar);
+        // Two or more chars, emit a URX_STRING to match them.
+        if (fLiteralChars.length() > 0x00ffffff || fRXPat->fLiteralText.length() > 0x00ffffff) {
+            error(U_REGEX_PATTERN_TOO_BIG);
+        }
+        if (fModeFlags & UREGEX_CASE_INSENSITIVE) {
+            appendOp(URX_STRING_I, fRXPat->fLiteralText.length());
+        } else {
+            // TODO here:  add optimization to split case sensitive strings of length two
+            //             into two single char ops, for efficiency.
+            appendOp(URX_STRING, fRXPat->fLiteralText.length());
+        }
+        appendOp(URX_STRING_LEN, fLiteralChars.length());
+        
+        // Add this string into the accumulated strings of the compiled pattern.
+        fRXPat->fLiteralText.append(fLiteralChars);
     }
+
+    fLiteralChars.remove();
 }
 
 
+int32_t RegexCompile::buildOp(int32_t type, int32_t val) {
+    if (U_FAILURE(*fStatus)) {
+        return 0;
+    }
+    if (type < 0 || type > 255) {
+        U_ASSERT(FALSE);
+        error(U_REGEX_INTERNAL_ERROR);
+        type = URX_RESERVED_OP;
+    }
+    if (val > 0x00ffffff) {
+        U_ASSERT(FALSE);
+        error(U_REGEX_INTERNAL_ERROR);
+        val = 0;
+    }
+    if (val < 0) {
+        if (!(type == URX_RESERVED_OP_N || type == URX_RESERVED_OP)) {
+            U_ASSERT(FALSE);
+            error(U_REGEX_INTERNAL_ERROR);
+            return -1;
+        }
+        if (URX_TYPE(val) != 0xff) {
+            U_ASSERT(FALSE);
+            error(U_REGEX_INTERNAL_ERROR);
+            return -1;
+        }
+        type = URX_RESERVED_OP_N;
+    }
+    return (type << 24) | val;
+}
 
 
+//------------------------------------------------------------------------------
+//
+//   appendOp()             Append a new instruction onto the compiled pattern
+//                          Includes error checking, limiting the size of the
+//                          pattern to lengths that can be represented in the
+//                          24 bit operand field of an instruction.
+//
+//------------------------------------------------------------------------------
+void RegexCompile::appendOp(int32_t op) {
+    if (U_FAILURE(*fStatus)) {
+        return;
+    }
+    fRXPat->fCompiledPat->addElement(op, *fStatus);
+    if ((fRXPat->fCompiledPat->size() > 0x00fffff0) && U_SUCCESS(*fStatus)) {
+        error(U_REGEX_PATTERN_TOO_BIG);
+    }
+}
+
+void RegexCompile::appendOp(int32_t type, int32_t val) {
+    appendOp(buildOp(type, val));
+}
 
 
 //------------------------------------------------------------------------------
@@ -1946,7 +1871,7 @@
     UVector64 *code = fRXPat->fCompiledPat;
     U_ASSERT(where>0 && where < code->size());
 
-    int32_t  nop = URX_BUILD(URX_NOP, 0);
+    int32_t  nop = buildOp(URX_NOP, 0);
     code->insertElementAt(nop, where, *fStatus);
 
     // Walk through the pattern, looking for any ops with targets that
@@ -1967,7 +1892,7 @@
             // Target location for this opcode is after the insertion point and
             //   needs to be incremented to adjust for the insertion.
             opValue++;
-            op = URX_BUILD(opType, opValue);
+            op = buildOp(opType, opValue);
             code->setElementAt(op, loc);
         }
     }
@@ -1992,6 +1917,58 @@
 }
 
 
+//------------------------------------------------------------------------------
+//
+//   allocateData()        Allocate storage in the matcher's static data area.
+//                         Return the index for the newly allocated data.
+//                         The storage won't actually exist until we are running a match
+//                         operation, but the storage indexes are inserted into various
+//                         opcodes while compiling the pattern.
+//
+//------------------------------------------------------------------------------
+int32_t RegexCompile::allocateData(int32_t size) {
+    if (U_FAILURE(*fStatus)) {
+        return 0;
+    }
+    if (size <= 0 || size > 0x100 || fRXPat->fDataSize < 0) {
+        error(U_REGEX_INTERNAL_ERROR);
+        return 0;
+    }
+    int32_t dataIndex = fRXPat->fDataSize;
+    fRXPat->fDataSize += size;
+    if (fRXPat->fDataSize >= 0x00fffff0) {
+        error(U_REGEX_INTERNAL_ERROR);
+    }
+    return dataIndex;
+}
+
+
+//------------------------------------------------------------------------------
+//
+//   allocateStackData()   Allocate space in the back-tracking stack frame.
+//                         Return the index for the newly allocated data.
+//                         The frame indexes are inserted into various
+//                         opcodes while compiling the pattern, meaning that frame
+//                         size must be restricted to the size that will fit
+//                         as an operand (24 bits).
+//
+//------------------------------------------------------------------------------
+int32_t RegexCompile::allocateStackData(int32_t size) {
+    if (U_FAILURE(*fStatus)) {
+        return 0;
+    }
+    if (size <= 0 || size > 0x100 || fRXPat->fFrameSize < 0) {
+        error(U_REGEX_INTERNAL_ERROR);
+        return 0;
+    }
+    int32_t dataIndex = fRXPat->fFrameSize;
+    fRXPat->fFrameSize += size;
+    if (fRXPat->fFrameSize >= 0x00fffff0) {
+        error(U_REGEX_PATTERN_TOO_BIG);
+    }
+    return dataIndex;
+}
+
 
 //------------------------------------------------------------------------------
 //
@@ -2013,6 +1990,8 @@
 //------------------------------------------------------------------------------
 int32_t   RegexCompile::blockTopLoc(UBool reserveLoc) {
     int32_t   theLoc;
+    fixLiterals(TRUE);  // Emit code for any pending literals.
+                        //   If last item was a string, emit separate op for the its last char.
     if (fRXPat->fCompiledPat->size() == fMatchCloseParen)
     {
         // The item just processed is a parenthesized block.
@@ -2021,14 +2000,18 @@
         U_ASSERT(URX_TYPE(((uint32_t)fRXPat->fCompiledPat->elementAti(theLoc))) == URX_NOP);
     }
     else {
-        // Item just compiled is a single thing, a ".", or a single char, or a set reference.
+        // Item just compiled is a single thing, a ".", or a single char, a string or a set reference.
         // No slot for STATE_SAVE was pre-reserved in the compiled code.
         // We need to make space now.
-        fixLiterals(TRUE);  // If last item was a string, separate the last char.
         theLoc = fRXPat->fCompiledPat->size()-1;
+        int32_t opAtTheLoc = (int32_t)fRXPat->fCompiledPat->elementAti(theLoc);
+        if (URX_TYPE(opAtTheLoc) == URX_STRING_LEN) {
+            // Strings take two opcode, we want the position of the first one.
+            // We can have a string at this point if a single character case-folded to two.
+            theLoc--;
+        }
         if (reserveLoc) {
-            /*int32_t opAtTheLoc = fRXPat->fCompiledPat->elementAti(theLoc);*/
-            int32_t  nop = URX_BUILD(URX_NOP, 0);
+            int32_t  nop = buildOp(URX_NOP, 0);
             fRXPat->fCompiledPat->insertElementAt(nop, theLoc, *fStatus);
         }
     }
@@ -2057,8 +2040,7 @@
         return;
     }
 
-    // Force any literal chars that may follow the close paren to start a new string,
-    //   and not attach to any preceding it.
+    // Emit code for any pending literals.
     fixLiterals(FALSE);
 
     // Fixup any operations within the just-closed parenthesized group
@@ -2104,8 +2086,7 @@
             U_ASSERT(URX_TYPE(captureOp) == URX_START_CAPTURE);
 
             int32_t   frameVarLocation = URX_VAL(captureOp);
-            int32_t   endCaptureOp = URX_BUILD(URX_END_CAPTURE, frameVarLocation);
-            fRXPat->fCompiledPat->addElement(endCaptureOp, *fStatus);
+            appendOp(URX_END_CAPTURE, frameVarLocation);
         }
         break;
     case atomic:
@@ -2116,8 +2097,7 @@
             int32_t   stoOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen+1);
             U_ASSERT(URX_TYPE(stoOp) == URX_STO_SP);
             int32_t   stoLoc = URX_VAL(stoOp);
-            int32_t   ldOp   = URX_BUILD(URX_LD_SP, stoLoc);
-            fRXPat->fCompiledPat->addElement(ldOp, *fStatus);
+            appendOp(URX_LD_SP, stoLoc);
         }
         break;
 
@@ -2126,8 +2106,7 @@
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-5);
             U_ASSERT(URX_TYPE(startOp) == URX_LA_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LA_END, dataLoc);
         }
         break;
 
@@ -2137,19 +2116,16 @@
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-1);
             U_ASSERT(URX_TYPE(startOp) == URX_LA_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            op               = URX_BUILD(URX_BACKTRACK, 0);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-            op               = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LA_END, dataLoc);
+            appendOp(URX_BACKTRACK, 0);
+            appendOp(URX_LA_END, dataLoc);
 
             // Patch the URX_SAVE near the top of the block.
             // The destination of the SAVE is the final LA_END that was just added.
             int32_t saveOp   = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen);
             U_ASSERT(URX_TYPE(saveOp) == URX_STATE_SAVE);
             int32_t dest     = fRXPat->fCompiledPat->size()-1;
-            saveOp           = URX_BUILD(URX_STATE_SAVE, dest);
+            saveOp           = buildOp(URX_STATE_SAVE, dest);
             fRXPat->fCompiledPat->setElementAt(saveOp, fMatchOpenParen);
         }
         break;
@@ -2162,10 +2138,8 @@
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-4);
             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LB_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
-                    op       = URX_BUILD(URX_LA_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LB_END, dataLoc);
+            appendOp(URX_LA_END, dataLoc);
 
             // Determine the min and max bounds for the length of the
             //  string that the pattern can match.
@@ -2201,8 +2175,7 @@
             int32_t  startOp = (int32_t)fRXPat->fCompiledPat->elementAti(fMatchOpenParen-5);
             U_ASSERT(URX_TYPE(startOp) == URX_LB_START);
             int32_t dataLoc  = URX_VAL(startOp);
-            int32_t op       = URX_BUILD(URX_LBN_END, dataLoc);
-            fRXPat->fCompiledPat->addElement(op, *fStatus);
+            appendOp(URX_LBN_END, dataLoc);
 
             // Determine the min and max bounds for the length of the
             //  string that the pattern can match.
@@ -2227,7 +2200,7 @@
 
             // Insert the pattern location to continue at after a successful match
             //  as the last operand of the URX_LBN_CONT
-            op = URX_BUILD(URX_RELOC_OPRND, fRXPat->fCompiledPat->size());
+            int32_t op = buildOp(URX_RELOC_OPRND, fRXPat->fCompiledPat->size());
             fRXPat->fCompiledPat->setElementAt(op,  fMatchOpenParen-1);
         }
         break;
@@ -2268,7 +2241,7 @@
     case 0:
         {
             // Set of no elements.   Always fails to match.
-            fRXPat->fCompiledPat->addElement(URX_BUILD(URX_BACKTRACK, 0), *fStatus);
+            appendOp(URX_BACKTRACK, 0);
             delete theSet;
         }
         break;
@@ -2289,8 +2262,7 @@
             //  Put it into the compiled pattern as a set.
             int32_t setNumber = fRXPat->fSets->size();
             fRXPat->fSets->addElement(theSet, *fStatus);
-            int32_t setOp = URX_BUILD(URX_SETREF, setNumber);
-            fRXPat->fCompiledPat->addElement(setOp, *fStatus);
+            appendOp(URX_SETREF, setNumber);
         }
     }
 }
@@ -2324,10 +2296,10 @@
 
     // The operands for the CTR_INIT opcode include the index in the matcher data
     //   of the counter.  Allocate it now.
-    int32_t   counterLoc = fRXPat->fFrameSize;
-    fRXPat->fFrameSize++;
+    int32_t   dataSize = fIntervalUpper < 0 ? 2 : 1;
+    int32_t   counterLoc = allocateStackData(dataSize);
 
-    int32_t   op = URX_BUILD(InitOp, counterLoc);
+    int32_t   op = buildOp(InitOp, counterLoc);
     fRXPat->fCompiledPat->setElementAt(op, topOfBlock);
 
     // The second operand of CTR_INIT is the location following the end of the loop.
@@ -2335,7 +2307,7 @@
     //   compilation of something later on causes the code to grow and the target
     //   position to move.
     int32_t loopEnd = fRXPat->fCompiledPat->size();
-    op = URX_BUILD(URX_RELOC_OPRND, loopEnd);
+    op = buildOp(URX_RELOC_OPRND, loopEnd);
     fRXPat->fCompiledPat->setElementAt(op, topOfBlock+1);
 
     // Followed by the min and max counts.
@@ -2344,8 +2316,7 @@
 
     // Apend the CTR_LOOP op.  The operand is the location of the CTR_INIT op.
     //   Goes at end of the block being looped over, so just append to the code so far.
-    op = URX_BUILD(LoopOp, topOfBlock);
-    fRXPat->fCompiledPat->addElement(op, *fStatus);
+    appendOp(LoopOp, topOfBlock);
 
     if ((fIntervalLow & 0xff000000) != 0 ||
         (fIntervalUpper > 0 && (fIntervalUpper & 0xff000000) != 0)) {
@@ -2398,7 +2369,7 @@
     //
     int32_t endOfSequenceLoc = fRXPat->fCompiledPat->size()-1
                                 + fIntervalUpper + (fIntervalUpper-fIntervalLow);
-    int32_t saveOp = URX_BUILD(URX_STATE_SAVE, endOfSequenceLoc);
+    int32_t saveOp = buildOp(URX_STATE_SAVE, endOfSequenceLoc);
     if (fIntervalLow == 0) {
         insertOp(topOfBlock);
         fRXPat->fCompiledPat->setElementAt(saveOp, topOfBlock);
@@ -2411,13 +2382,10 @@
     //    it was put there when it was originally encountered.
     int32_t i;
     for (i=1; i<fIntervalUpper; i++ ) {
-        if (i == fIntervalLow) {
-            fRXPat->fCompiledPat->addElement(saveOp, *fStatus);
-        }
-        if (i > fIntervalLow) {
-            fRXPat->fCompiledPat->addElement(saveOp, *fStatus);
+        if (i >= fIntervalLow) {
+            appendOp(saveOp);
         }
-        fRXPat->fCompiledPat->addElement(op, *fStatus);
+        appendOp(op);
     }
     return TRUE;
 }
@@ -2614,11 +2582,17 @@
             if (currentLen == 0) {
                 UChar32  c = URX_VAL(op);
                 if (u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
-                    // character may have distinct cased forms.  Add all of them
-                    //   to the set of possible starting match chars.
-                    UnicodeSet s(c, c);
-                    s.closeOver(USET_CASE_INSENSITIVE);
-                    fRXPat->fInitialChars->addAll(s);
+
+                    // Disable optimizations on first char of match.
+                    // TODO: Compute the set of chars that case fold to this char, or to
+                    //       a string that begins with this char.
+                    //       For simple case folding, this code worked:
+                    //   UnicodeSet s(c, c);
+                    //   s.closeOver(USET_CASE_INSENSITIVE);
+                    //   fRXPat->fInitialChars->addAll(s);
+
+                    fRXPat->fInitialChars->clear();
+                    fRXPat->fInitialChars->complement();
                 } else {
                     // Char has no case variants.  Just add it as-is to the
                     //   set of possible starting chars.
@@ -2742,7 +2716,13 @@
                     int32_t stringStartIdx = URX_VAL(op);
                     UChar32  c = fRXPat->fLiteralText.char32At(stringStartIdx);
                     UnicodeSet s(c, c);
-                    s.closeOver(USET_CASE_INSENSITIVE);
+
+                    // TODO:  compute correct set of starting chars for full case folding.
+                    //        For the moment, say any char can start.
+                    // s.closeOver(USET_CASE_INSENSITIVE);
+                    s.clear();
+                    s.complement();
+
                     fRXPat->fInitialChars->addAll(s);
                     numInitialStrings += 2;  // Matching on an initial string not possible.
                 }
@@ -3049,7 +3029,6 @@
 
 
         case URX_STRING:
-        case URX_STRING_I:
             {
                 loc++;
                 int32_t stringLenOp = (int32_t)fRXPat->fCompiledPat->elementAti(loc);
@@ -3058,6 +3037,18 @@
             break;
 
 
+        case URX_STRING_I:
+            {
+                loc++;
+                // TODO: with full case folding, matching input text may be shorter than
+                //       the string we have here.  More smarts could put some bounds on it.
+                //       Assume a min length of one for now.  A min length of zero causes
+                //        optimization failures for a pattern like "string"+
+                // currentLen += URX_VAL(stringLenOp);
+                currentLen += 1;
+            }
+            break;
+
         case URX_CTR_INIT:
         case URX_CTR_INIT_NG:
             {
@@ -3164,6 +3155,16 @@
     return currentLen;
 }
 
+// Increment with overflow check.
+// val and delta will both be positive.
+
+static int32_t safeIncrement(int32_t val, int32_t delta) {
+    if (INT32_MAX - val > delta) {
+        return val + delta;
+    } else {
+        return INT32_MAX;
+    }
+}
 
 
 //------------------------------------------------------------------------------
@@ -3260,15 +3261,15 @@
         case URX_DOTANY_ALL:
         case URX_DOTANY:
         case URX_DOTANY_UNIX:
-            currentLen+=2;
+            currentLen = safeIncrement(currentLen, 2);
             break;
 
             // Single literal character.  Increase current max length by one or two,
             //       depending on whether the char is in the supplementary range.
         case URX_ONECHAR:
-            currentLen++;
+            currentLen = safeIncrement(currentLen, 1);
             if (URX_VAL(op) > 0x10000) {
-                currentLen++;
+                currentLen = safeIncrement(currentLen, 1);
             }
             break;
 
@@ -3321,14 +3322,19 @@
 
 
         case URX_STRING:
-        case URX_STRING_I:
             {
                 loc++;
                 int32_t stringLenOp = (int32_t)fRXPat->fCompiledPat->elementAti(loc);
-                currentLen += URX_VAL(stringLenOp);
+                currentLen = safeIncrement(currentLen, URX_VAL(stringLenOp));
+                break;
             }
-            break;
 
+        case URX_STRING_I:
+            // TODO:  Is the case-folded string the longest?
+            //        If so we can optimize this the same as URX_STRING.
+            loc++;
+            currentLen = INT32_MAX;
+            break;
 
         case URX_CTR_INIT:
         case URX_CTR_INIT_NG:
@@ -3407,10 +3413,6 @@
 //                back-reference fixup is also performed here (adjusting
 //                back-reference operands to point to the correct frame offsets).
 //
-//                In addition, case-insensitive character and string literals are
-//                now case-folded here, rather than when first parsed or at match
-//                time.
-//
 //------------------------------------------------------------------------------
 void RegexCompile::stripNOPs() {
 
@@ -3434,7 +3436,6 @@
     }
     
     UnicodeString caseStringBuffer;
-    int32_t stringDelta = 0;
 
     // Make a second pass over the code, removing the NOPs by moving following
     //  code up, and patching operands that refer to code locations that
@@ -3462,51 +3463,12 @@
                 int32_t  operandAddress = URX_VAL(op);
                 U_ASSERT(operandAddress>=0 && operandAddress<deltas.size());
                 int32_t fixedOperandAddress = operandAddress - deltas.elementAti(operandAddress);
-                op = URX_BUILD(opType, fixedOperandAddress);
+                op = buildOp(opType, fixedOperandAddress);
                 fRXPat->fCompiledPat->setElementAt(op, dst);
                 dst++;
                 break;
             }
 
-        case URX_ONECHAR_I:
-            {
-                UChar32 c = URX_VAL(op);
-                if (u_hasBinaryProperty(c, UCHAR_CASE_SENSITIVE)) {
-                    // We have a cased character to fold
-                    c  = u_foldCase(c, U_FOLD_CASE_DEFAULT);
-                    op = URX_BUILD(URX_ONECHAR_I, c);
-                }
-                
-                fRXPat->fCompiledPat->setElementAt(op, dst);
-                dst++;
-                break;
-            }
-        case URX_STRING_I:
-            {
-                op = URX_BUILD(URX_STRING_I, URX_VAL(op)+stringDelta);
-                
-                src++;
-                int32_t lengthOp = (int32_t)fRXPat->fCompiledPat->elementAti(src);
-                
-                caseStringBuffer.setTo(fRXPat->fLiteralText, URX_VAL(op), URX_VAL(lengthOp));
-                caseStringBuffer.foldCase(U_FOLD_CASE_DEFAULT);
-                
-                int32_t newLen = caseStringBuffer.length();
-                if (newLen <= URX_VAL(lengthOp)) {
-                    // don't shift if we don't have to, take the tiny memory hit of a smaller string
-                    fRXPat->fLiteralText.replace(URX_VAL(op), newLen, caseStringBuffer);
-                } else {
-                    // shift other strings over...at least UnicodeString handles this for us!
-                    fRXPat->fLiteralText.replace(URX_VAL(op), URX_VAL(lengthOp), caseStringBuffer);
-                    stringDelta += newLen - URX_VAL(lengthOp);
-                }
-                lengthOp = URX_BUILD(URX_STRING_LEN, newLen);
-                
-                fRXPat->fCompiledPat->setElementAt(op, dst);
-                fRXPat->fCompiledPat->setElementAt(lengthOp, dst+1);
-                dst += 2;
-                break;
-            }
         case URX_BACKREF:
         case URX_BACKREF_I:
             {
@@ -3516,21 +3478,19 @@
                     break;
                 }
                 where = fRXPat->fGroupMap->elementAti(where-1);
-                op    = URX_BUILD(opType, where);
+                op    = buildOp(opType, where);
                 fRXPat->fCompiledPat->setElementAt(op, dst);
                 dst++;
                 
                 fRXPat->fNeedsAltInput = TRUE;
                 break;
             }
-        case URX_STRING:
-            op = URX_BUILD(URX_STRING, URX_VAL(op)+stringDelta);
-            // continue
         case URX_RESERVED_OP:
         case URX_RESERVED_OP_N:
         case URX_BACKTRACK:
         case URX_END:
         case URX_ONECHAR:
+        case URX_STRING:
         case URX_STRING_LEN:
         case URX_START_CAPTURE:
         case URX_END_CAPTURE:
@@ -3556,6 +3516,8 @@
         case URX_STO_INP_LOC:
         case URX_LA_START:
         case URX_LA_END:
+        case URX_ONECHAR_I:
+        case URX_STRING_I:
         case URX_DOLLAR_M:
         case URX_CARET_M:
         case URX_CARET_M_UNIX:
@@ -3867,7 +3829,7 @@
 //------------------------------------------------------------------------------
 //
 //  scanNamedChar
- //            Get a UChar32 from a \N{UNICODE CHARACTER NAME} in the pattern.
+//            Get a UChar32 from a \N{UNICODE CHARACTER NAME} in the pattern.
 //
 //             The scan position will be at the 'N'.  On return
 //             the scan position should be just after the '}'
Index: icu-4.8.1.1/source/i18n/regexcmp.h
===================================================================
--- icu-4.8.1.1.orig/source/i18n/regexcmp.h	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/regexcmp.h	2015-03-02 08:20:03.441220865 -0500
@@ -100,10 +100,16 @@
                                int32_t LoopOp);
     UBool       compileInlineInterval();             // Generate inline code for a {min,max} quantifier
     void        literalChar(UChar32 c);              // Compile a literal char
-    void        fixLiterals(UBool split=FALSE);      // Fix literal strings.
+    void        fixLiterals(UBool split=FALSE);      // Generate code for pending literal characters.
     void        insertOp(int32_t where);             // Open up a slot for a new op in the
                                                      //   generated code at the specified location.
-    void        emitONE_CHAR(UChar32 c);             // Emit a ONE_CHAR op into the compiled code,
+    void        appendOp(int32_t op);                // Append a new op to the compiled pattern.
+    void        appendOp(int32_t type, int32_t val); // Build & append a new op to the compiled pattern.
+    int32_t     buildOp(int32_t type, int32_t val);  // Construct a new pcode instruction.
+    int32_t     allocateData(int32_t size);          // Allocate space in the matcher data area.
+                                                     //   Return index of the newly allocated data.
+    int32_t     allocateStackData(int32_t size);     // Allocate space in the match back-track stack frame.
+                                                     //   Return offset index in the frame.
                                                      //   taking case mode into account.
     int32_t     minMatchLength(int32_t start,
                                int32_t end);
@@ -162,10 +168,11 @@
                                                      //   until last flag is scanned.
     UBool                         fSetModeFlag;      // true for (?ismx, false for (?-ismx
 
-
-    int32_t                       fStringOpStart;    // While a literal string is being scanned
-                                                     //   holds the start index within RegexPattern.
-                                                     //   fLiteralText where the string is being stored.
+    UnicodeString                 fLiteralChars;     // Literal chars or strings from the pattern are accumulated here.
+                                                     //   Once completed, meaning that some non-literal pattern
+                                                     //   construct is encountered, the appropriate opcodes
+                                                     //   to match the literal will be generated, and this
+                                                     //   string will be cleared.
 
     int64_t                       fPatternLength;    // Length of the input pattern string.
     
Index: icu-4.8.1.1/source/i18n/regeximp.h
===================================================================
--- icu-4.8.1.1.orig/source/i18n/regeximp.h	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/regeximp.h	2015-03-02 08:20:03.441220865 -0500
@@ -12,11 +12,21 @@
 #ifndef _REGEXIMP_H
 #define _REGEXIMP_H
 
+#include "unicode/utypes.h"
+#include "unicode/uobject.h"
+#include "unicode/uniset.h"
+#include "unicode/utext.h"
+
 #include "cmemory.h"
+#include "ucase.h"
 
 U_NAMESPACE_BEGIN
 
-#ifdef REGEX_DEBUG   /* For debugging, define REGEX_DEBUG in regex.h, not here in this file. */
+// For debugging, define REGEX_DEBUG 
+// To define with configure,
+//   ./runConfigureICU --enable-debug --disable-release Linux CPPFLAGS="-DREGEX_DEBUG"
+
+#ifdef REGEX_DEBUG   
 //
 //  debugging options.  Enable one or more of the three #defines immediately following
 //
@@ -244,7 +254,6 @@
 //
 //  Convenience macros for assembling and disassembling a compiled operation.
 //
-#define URX_BUILD(type, val) (int32_t)((type << 24) | (val))
 #define URX_TYPE(x)          ((uint32_t)(x) >> 24)
 #define URX_VAL(x)           ((x) & 0xffffff)
 
@@ -352,6 +361,61 @@
    uprv_memcpy(d, s.d, sizeof(d));
 }
 
+
+//  Case folded UText Iterator helper class.
+//  Wraps a UText, provides a case-folded enumeration over its contents.
+//  Used in implementing case insensitive matching constructs.
+//  Implementation in rematch.cpp
+
+class CaseFoldingUTextIterator: public UMemory {
+      public:
+        CaseFoldingUTextIterator(UText &text);
+        ~CaseFoldingUTextIterator();
+
+        UChar32 next();           // Next case folded character 
+
+        UBool   inExpansion();    // True if last char returned from next() and the 
+                                  //  next to be returned both originated from a string
+                                  //  folding of the same code point from the orignal UText.
+      private:
+        UText             &fUText;
+        const  UCaseProps *fcsp;
+        const  UChar      *fFoldChars;
+        int32_t            fFoldLength;
+        int32_t            fFoldIndex;
+
+};
+
+
+// Case folded UChar * string iterator.
+//  Wraps a UChar  *, provides a case-folded enumeration over its contents.
+//  Used in implementing case insensitive matching constructs.
+//  Implementation in rematch.cpp
+
+class CaseFoldingUCharIterator: public UMemory {
+      public:
+        CaseFoldingUCharIterator(const UChar *chars, int64_t start, int64_t limit);
+        ~CaseFoldingUCharIterator();
+
+        UChar32 next();           // Next case folded character 
+
+        UBool   inExpansion();    // True if last char returned from next() and the 
+                                  //  next to be returned both originated from a string
+                                  //  folding of the same code point from the orignal UText.
+
+        int64_t  getIndex();      // Return the current input buffer index.
+
+      private:
+        const  UChar      *fChars;
+        int64_t            fIndex;
+        int64_t            fLimit;
+        const  UCaseProps *fcsp;
+        const  UChar      *fFoldChars;
+        int32_t            fFoldLength;
+        int32_t            fFoldIndex;
+
+};
+
 U_NAMESPACE_END
 #endif
 
Index: icu-4.8.1.1/source/test/intltest/regextst.cpp
===================================================================
--- icu-4.8.1.1.orig/source/test/intltest/regextst.cpp	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/test/intltest/regextst.cpp	2015-03-02 08:47:35.110822656 -0500
@@ -127,6 +127,9 @@
         case 20: name = "CheckInvBufSize";
             if (exec) CheckInvBufSize();
             break;
+        case 21: name = "TestBug11371";
+            if (exec) TestBug11371();
+            break;
 
         default: name = "";
             break; //needed to end loop
@@ -575,8 +578,13 @@
         // REGEX_TESTLM("a\N{LATIN SMALL LETTER B}c", "abc", FALSE, FALSE);
         UParseError pe;
         UErrorCode  status = U_ZERO_ERROR;
-        RegexPattern::compile("^(?:a?b?)*$", 0, pe, status);
-        // REGEX_FIND("(?>(abc{2,4}?))(c*)", "<0>ab<1>cc</1><2>ccc</2></0>ddd");
+        RegexPattern *pattern;
+        pattern = RegexPattern::compile("aßx", UREGEX_CASE_INSENSITIVE, pe, status);
+        RegexPatternDump(pattern);
+        RegexMatcher *m = pattern->matcher("aßxzzz", status);
+        UBool result = m->find();
+        printf("result = %d\n", result);
+        // REGEX_FIND("", "<0>ab<1>cc</1><2>ccc</2></0>ddd");
         // REGEX_FIND("(X([abc=X]+)+X)|(y[abc=]+)", "=XX====================");
     }
     exit(1);
@@ -5093,6 +5101,50 @@
     utext_close(&patternText);
 }
 
+void RegexTest::TestBug11371() {
+    if (quick) {
+        logln("Skipping test. Runs in exhuastive mode only.");
+        return;
+    }
+    UErrorCode status = U_ZERO_ERROR;
+    UnicodeString patternString;
+
+    for (int i=0; i<8000000; i++) {
+        patternString.append(UnicodeString("()"));
+    }
+    LocalPointer<RegexPattern> compiledPat(RegexPattern::compile(patternString, 0, status));
+    if (status != U_REGEX_PATTERN_TOO_BIG) {
+        errln("File %s, line %d expected status=U_REGEX_PATTERN_TOO_BIG; got %s.",
+              __FILE__, __LINE__, u_errorName(status));
+    }
+
+    status = U_ZERO_ERROR;
+    patternString = "(";
+    for (int i=0; i<20000000; i++) {
+        patternString.append(UnicodeString("A++"));
+    }
+    patternString.append(UnicodeString("){0}B++"));
+    LocalPointer<RegexPattern> compiledPat2(RegexPattern::compile(patternString, 0, status));
+    if (status != U_REGEX_PATTERN_TOO_BIG) {
+        errln("File %s, line %d expected status=U_REGEX_PATTERN_TOO_BIG; got %s.",
+              __FILE__, __LINE__, u_errorName(status));
+    }
+
+    // Pattern with too much string data, such that string indexes overflow operand data field size
+    // in compiled instruction.
+    status = U_ZERO_ERROR;
+    patternString = "";
+    while (patternString.length() < 0x00ffffff) {
+        patternString.append(UnicodeString("stuff and things dont you know, these are a few of my favorite strings\n"));
+    }
+    patternString.append(UnicodeString("X? trailing string"));
+    LocalPointer<RegexPattern> compiledPat3(RegexPattern::compile(patternString, 0, status));
+    if (status != U_REGEX_PATTERN_TOO_BIG) {
+        errln("File %s, line %d expected status=U_REGEX_PATTERN_TOO_BIG; got %s.",
+              __FILE__, __LINE__, u_errorName(status));
+    }
+}
+
 //--------------------------------------------------------------
 //
 //  Bug7651   Regex pattern that exceeds default operator stack depth in matcher.
Index: icu-4.8.1.1/source/test/intltest/regextst.h
===================================================================
--- icu-4.8.1.1.orig/source/test/intltest/regextst.h	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/test/intltest/regextst.h	2015-03-02 08:20:03.445220898 -0500
@@ -50,6 +50,7 @@
     // The following functions are internal to the regexp tests.
     virtual void assertUText(const char *expected, UText *actual, const char *file, int line);
     virtual void assertUTextInvariant(const char *invariant, UText *actual, const char *file, int line);
+    virtual void TestBug11371();
     virtual UBool doRegexLMTest(const char *pat, const char *text, UBool looking, UBool match, int32_t line);
     virtual UBool doRegexLMTestUTF8(const char *pat, const char *text, UBool looking, UBool match, int32_t line);
     virtual void regex_find(const UnicodeString &pat, const UnicodeString &flags,
Index: icu-4.8.1.1/source/i18n/Makefile.in
===================================================================
--- icu-4.8.1.1.orig/source/i18n/Makefile.in	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/Makefile.in	2015-03-02 08:20:03.445220898 -0500
@@ -64,7 +64,7 @@
 OBJECTS = ucln_in.o \
 fmtable.o format.o msgfmt.o umsg.o numfmt.o unum.o decimfmt.o dcfmtsym.o \
 ucurr.o digitlst.o fmtable_cnv.o \
-choicfmt.o datefmt.o smpdtfmt.o reldtfmt.o dtfmtsym.o udat.o dtptngen.o \
+choicfmt.o datefmt.o smpdtfmt.o reldtfmt.o dtfmtsym.o udat.o dtptngen.o udatpg.o \
 nfrs.o nfrule.o nfsubs.o rbnf.o numsys.o ucsdet.o \
 ucal.o calendar.o gregocal.o timezone.o simpletz.o olsontz.o \
 astro.o taiwncal.o buddhcal.o persncal.o islamcal.o japancal.o gregoimp.o hebrwcal.o \
@@ -76,7 +76,7 @@
 cpdtrans.o rbt.o rbt_data.o rbt_pars.o rbt_rule.o rbt_set.o \
 nultrans.o remtrans.o casetrn.o titletrn.o tolowtrn.o toupptrn.o anytrans.o \
 name2uni.o uni2name.o nortrans.o quant.o transreg.o brktrans.o \
-regexcmp.o rematch.o repattrn.o regexst.o regextxt.o udatpg.o uregex.o uregexc.o \
+regexcmp.o rematch.o repattrn.o regexst.o regextxt.o regeximp.o uregex.o uregexc.o \
 ulocdata.o measfmt.o currfmt.o curramt.o currunit.o measure.o utmscale.o \
 csdetect.o csmatch.o csr2022.o csrecog.o csrmbcs.o csrsbcs.o csrucode.o csrutf8.o inputext.o \
 wintzimpl.o windtfmt.o winnmfmt.o basictz.o dtrule.o rbtz.o tzrule.o tztrans.o vtzone.o zonemeta.o \
Index: icu-4.8.1.1/source/i18n/i18n.vcxproj
===================================================================
--- icu-4.8.1.1.orig/source/i18n/i18n.vcxproj	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/i18n.vcxproj	2015-03-02 08:20:03.445220898 -0500
@@ -372,6 +372,7 @@
       <DisableLanguageExtensions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</DisableLanguageExtensions>
     </ClCompile>
     <ClCompile Include="regexcmp.cpp" />
+    <ClCompile Include="regeximp.cpp" />
     <ClCompile Include="regexst.cpp" />
     <ClCompile Include="regextxt.cpp" />
     <ClCompile Include="rematch.cpp" />
Index: icu-4.8.1.1/source/i18n/i18n.vcxproj.filters
===================================================================
--- icu-4.8.1.1.orig/source/i18n/i18n.vcxproj.filters	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/i18n.vcxproj.filters	2015-03-02 08:20:03.445220898 -0500
@@ -333,6 +333,9 @@
     <ClCompile Include="regexcmp.cpp">
       <Filter>regex</Filter>
     </ClCompile>
+    <ClCompile Include="regeximp.cpp">
+      <Filter>regex</Filter>
+    </ClCompile>
     <ClCompile Include="regexst.cpp">
       <Filter>regex</Filter>
     </ClCompile>
Index: icu-4.8.1.1/source/i18n/regeximp.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ icu-4.8.1.1/source/i18n/regeximp.cpp	2015-03-02 08:20:03.445220898 -0500
@@ -0,0 +1,120 @@
+//
+//   Copyright (C) 2012 International Business Machines Corporation
+//   and others. All rights reserved.
+//
+//   file:  regeximp.cpp
+//
+//           ICU Regular Expressions,
+//             miscellaneous implementation functions.
+//
+
+#include "unicode/utypes.h"
+
+#if !UCONFIG_NO_REGULAR_EXPRESSIONS
+#include "regeximp.h"
+#include "unicode/utf16.h"
+
+U_NAMESPACE_BEGIN
+
+CaseFoldingUTextIterator::CaseFoldingUTextIterator(UText &text) :
+   fUText(text), fcsp(NULL), fFoldChars(NULL), fFoldLength(0) {
+   fcsp = ucase_getSingleton();
+}
+
+CaseFoldingUTextIterator::~CaseFoldingUTextIterator() {}
+
+UChar32 CaseFoldingUTextIterator::next() {
+    UChar32  foldedC;
+    UChar32  originalC;
+    if (fFoldChars == NULL) {
+        // We are not in a string folding of an earlier character.
+        // Start handling the next char from the input UText.
+        originalC = UTEXT_NEXT32(&fUText);
+        if (originalC == U_SENTINEL) {
+            return originalC;
+        }
+        fFoldLength = ucase_toFullFolding(fcsp, originalC, &fFoldChars, U_FOLD_CASE_DEFAULT);
+        if (fFoldLength >= UCASE_MAX_STRING_LENGTH || fFoldLength < 0) {
+            // input code point folds to a single code point, possibly itself.
+            // See comment in ucase.h for explanation of return values from ucase_toFullFoldings.
+            if (fFoldLength < 0) {
+                fFoldLength = ~fFoldLength;
+            }
+            foldedC = (UChar32)fFoldLength;
+            fFoldChars = NULL;
+            return foldedC;
+        }
+        // String foldings fall through here.
+        fFoldIndex = 0;
+    }
+
+    U16_NEXT(fFoldChars, fFoldIndex, fFoldLength, foldedC);
+    if (fFoldIndex >= fFoldLength) {
+        fFoldChars = NULL;
+    }
+    return foldedC;
+}
+    
+
+UBool CaseFoldingUTextIterator::inExpansion() {
+    return fFoldChars != NULL;
+}
+
+
+
+CaseFoldingUCharIterator::CaseFoldingUCharIterator(const UChar *chars, int64_t start, int64_t limit) :
+   fChars(chars), fIndex(start), fLimit(limit), fcsp(NULL), fFoldChars(NULL), fFoldLength(0) {
+   fcsp = ucase_getSingleton();
+}
+
+
+CaseFoldingUCharIterator::~CaseFoldingUCharIterator() {}
+
+
+UChar32 CaseFoldingUCharIterator::next() {
+    UChar32  foldedC;
+    UChar32  originalC;
+    if (fFoldChars == NULL) {
+        // We are not in a string folding of an earlier character.
+        // Start handling the next char from the input UText.
+        if (fIndex >= fLimit) {
+            return U_SENTINEL;
+        }
+        U16_NEXT(fChars, fIndex, fLimit, originalC);
+
+        fFoldLength = ucase_toFullFolding(fcsp, originalC, &fFoldChars, U_FOLD_CASE_DEFAULT);
+        if (fFoldLength >= UCASE_MAX_STRING_LENGTH || fFoldLength < 0) {
+            // input code point folds to a single code point, possibly itself.
+            // See comment in ucase.h for explanation of return values from ucase_toFullFoldings.
+            if (fFoldLength < 0) {
+                fFoldLength = ~fFoldLength;
+            }
+            foldedC = (UChar32)fFoldLength;
+            fFoldChars = NULL;
+            return foldedC;
+        }
+        // String foldings fall through here.
+        fFoldIndex = 0;
+    }
+
+    U16_NEXT(fFoldChars, fFoldIndex, fFoldLength, foldedC);
+    if (fFoldIndex >= fFoldLength) {
+        fFoldChars = NULL;
+    }
+    return foldedC;
+}
+    
+
+UBool CaseFoldingUCharIterator::inExpansion() {
+    return fFoldChars != NULL;
+}
+
+int64_t CaseFoldingUCharIterator::getIndex() {
+    return fIndex;
+}
+
+
+U_NAMESPACE_END
+
+#endif
+
Index: icu-4.8.1.1/source/i18n/rematch.cpp
===================================================================
--- icu-4.8.1.1.orig/source/i18n/rematch.cpp	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/rematch.cpp	2015-03-02 08:20:03.449220931 -0500
@@ -51,8 +51,6 @@
 // Good idea in theory; unfortunately it only helps out a few specific
 // cases and slows the engine down a little in the rest.
 
-//#define REGEX_SMART_BACKTRACKING 1
-
 U_NAMESPACE_BEGIN
 
 // Default limit for the size of the back track stack, to avoid system
@@ -230,7 +228,7 @@
     fData              = fSmallData;
     fWordBreakItr      = NULL;
     
-    fStack             = new UVector64(status);
+    fStack             = NULL;
     fInputText         = NULL;
     fAltInputText      = NULL;
     fInput             = NULL;
@@ -260,6 +258,12 @@
         }
     }
 
+    fStack = new UVector64(status);
+    if (fStack == NULL) {
+        status = fDeferredStatus = U_MEMORY_ALLOCATION_ERROR;
+        return;
+    }
+
     reset(input);
     setStackLimit(DEFAULT_BACKTRACK_STACK_CAPACITY, status);
     if (U_FAILURE(status)) {
@@ -2854,36 +2858,6 @@
             } else {
                 fHitEnd = TRUE;
             }
-                
-            #ifdef REGEX_SMART_BACKTRACKING
-            if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                    UBool success = FALSE;
-                    UChar32 c = UTEXT_PREVIOUS32(fInputText);
-                    while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex) {
-                        if (c == opValue) {
-                            success = TRUE;
-                            break;
-                        } else if (c == U_SENTINEL) {
-                            break;
-                        }
-                        c = UTEXT_PREVIOUS32(fInputText);
-                    }
-                    if (success) {
-                        fHitEnd = FALSE;
-                        fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                        fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                        if (fp->fInputIdx > backSearchIndex) {
-                            fp = StateSave(fp, fp->fPatIdx, status);
-                        }
-                        fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                        break;
-                    }
-                }
-            }
-            #endif
-            
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
 
@@ -2893,76 +2867,38 @@
                 // Test input against a literal string.
                 // Strings require two slots in the compiled pattern, one for the
                 //   offset to the string text, and one for the length.
-                int32_t   stringStartIdx = opValue;
-                int32_t   stringLen;
 
+                int32_t   stringStartIdx = opValue;
                 op      = (int32_t)pat[fp->fPatIdx];     // Fetch the second operand
                 fp->fPatIdx++;
                 opType    = URX_TYPE(op);
-                stringLen = URX_VAL(op);
+                int32_t stringLen = URX_VAL(op);
                 U_ASSERT(opType == URX_STRING_LEN);
                 U_ASSERT(stringLen >= 2);
                                 
-                const UChar *patternChars = litText+stringStartIdx;
-                const UChar *patternEnd = patternChars+stringLen;
-                
+                const UChar *patternString = litText+stringStartIdx;
+                int32_t patternStringIndex = 0;
                 UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
-                UChar32 c;
+                UChar32 inputChar;
+                UChar32 patternChar;
                 UBool success = TRUE;
-                
-                while (patternChars < patternEnd && success) {
-                    c = UTEXT_NEXT32(fInputText);
-                    
-                    if (c != U_SENTINEL && UTEXT_GETNATIVEINDEX(fInputText) <= fActiveLimit) {
-                        if (U_IS_BMP(c)) {
-                            success = (*patternChars == c);
-                            patternChars += 1;
-                        } else if (patternChars+1 < patternEnd) {
-                            success = (*patternChars == U16_LEAD(c) && *(patternChars+1) == U16_TRAIL(c));
-                            patternChars += 2;
-                        }
-                    } else {
+                while (patternStringIndex < stringLen) {
+                    if (UTEXT_GETNATIVEINDEX(fInputText) >= fActiveLimit) {
                         success = FALSE;
-                        fHitEnd = TRUE;          //   TODO:  See ticket 6074
+                        fHitEnd = TRUE;
+                        break;
+                    }
+                    inputChar = UTEXT_NEXT32(fInputText);
+                    U16_NEXT(patternString, patternStringIndex, stringLen, patternChar);
+                    if (patternChar != inputChar) {
+                        success = FALSE;
+                        break;
                     }
                 }
                 
                 if (success) {
                     fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                 } else {
-                    #ifdef REGEX_SMART_BACKTRACKING
-                    if (fp->fInputIdx > backSearchIndex && fStack->size()) {
-                        REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                        if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                            // Reset to last start point
-                            UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
-                            patternChars = litText+stringStartIdx;
-                            
-                            // Search backwards for a possible start
-                            do {
-                                c = UTEXT_PREVIOUS32(fInputText);
-                                if (c == U_SENTINEL) {
-                                    break;
-                                } else if ((U_IS_BMP(c) && *patternChars == c) ||
-                                    (*patternChars == U16_LEAD(c) && *(patternChars+1) == U16_TRAIL(c))) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            } while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex);
-                            
-                            // And try again
-                            if (success) {
-                                fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                                fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                                if (fp->fInputIdx > backSearchIndex) {
-                                    fp = StateSave(fp, fp->fPatIdx, status);
-                                }
-                                fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                                break;
-                            }
-                        }
-                    }
-                    #endif
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 }
             }
@@ -3351,42 +3287,6 @@
                     fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
                 } else {
                     // the character wasn't in the set.
-                    #ifdef REGEX_SMART_BACKTRACKING
-                    if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                        REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                        if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                            // Try to find it, backwards
-                            UTEXT_PREVIOUS32(fInputText); // skip the first character we tried
-                            success = ((opValue & URX_NEG_SET) == URX_NEG_SET); // reset
-                            do {
-                                c = UTEXT_PREVIOUS32(fInputText);
-                                if (c == U_SENTINEL) {
-                                    break;
-                                } else if (c < 256) {
-                                    Regex8BitSet *s8 = &fPattern->fStaticSets8[opValue];
-                                    if (s8->contains(c)) {
-                                        success = !success;
-                                    }
-                                } else {
-                                    const UnicodeSet *s = fPattern->fStaticSets[opValue];
-                                    if (s->contains(c)) {
-                                        success = !success;
-                                    }
-                                }
-                            } while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex && !success);
-                            
-                            if (success && c != U_SENTINEL) {
-                                fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                                fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                                if (fp->fInputIdx > backSearchIndex) {
-                                    fp = StateSave(fp, fp->fPatIdx, status);
-                                }
-                                fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                                break;
-                            }
-                        }
-                    }
-                    #endif
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 }
             }
@@ -3422,44 +3322,6 @@
                     }
                 }
                 // the character wasn't in the set.
-                #ifdef REGEX_SMART_BACKTRACKING
-                if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                    REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                    if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                        // Try to find it, backwards
-                        UTEXT_PREVIOUS32(fInputText); // skip the first character we tried
-                        UBool success = FALSE;
-                        do {
-                            c = UTEXT_PREVIOUS32(fInputText);
-                            if (c == U_SENTINEL) {
-                                break;
-                            } else if (c < 256) {
-                                Regex8BitSet *s8 = &fPattern->fStaticSets8[opValue];
-                                if (s8->contains(c) == FALSE) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            } else {
-                                const UnicodeSet *s = fPattern->fStaticSets[opValue];
-                                if (s->contains(c) == FALSE) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            }
-                        } while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex);
-                        
-                        if (success) {
-                            fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                            fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                            if (fp->fInputIdx > backSearchIndex) {
-                                fp = StateSave(fp, fp->fPatIdx, status);
-                            }
-                            fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                            break;
-                        }
-                    }
-                }
-                #endif
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             }
             break;
@@ -3492,44 +3354,6 @@
                 }
                 
                 // the character wasn't in the set.
-                #ifdef REGEX_SMART_BACKTRACKING
-                if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                    REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                    if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                        // Try to find it, backwards
-                        UTEXT_PREVIOUS32(fInputText); // skip the first character we tried
-                        UBool success = FALSE;
-                        do {
-                            c = UTEXT_PREVIOUS32(fInputText);
-                            if (c == U_SENTINEL) {
-                                break;
-                            } else if (c < 256) {
-                                Regex8BitSet *s8 = &fPattern->fSets8[opValue];
-                                if (s8->contains(c)) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            } else {
-                                UnicodeSet *s = (UnicodeSet *)sets->elementAt(opValue);
-                                if (s->contains(c)) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            }
-                        } while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex);
-                        
-                        if (success) {
-                            fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                            fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                            if (fp->fInputIdx > backSearchIndex) {
-                                fp = StateSave(fp, fp->fPatIdx, status);
-                            }
-                            fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                            break;
-                        }
-                    }
-                }
-                #endif
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             }
             break;
@@ -3792,7 +3616,6 @@
             break;
 
         case URX_BACKREF:
-        case URX_BACKREF_I:
             {
                 U_ASSERT(opValue < fFrameSize);
                 int64_t groupStartIdx = fp->fExtra[opValue];
@@ -3801,32 +3624,96 @@
                 if (groupStartIdx < 0) {
                     // This capture group has not participated in the match thus far,
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
-                }
-                
-                if (groupEndIdx == groupStartIdx) {
-                    //   The capture group match was of an empty string.
-                    //   Verified by testing:  Perl matches succeed in this case, so
-                    //   we do too.
                     break;
                 }
-                
                 UTEXT_SETNATIVEINDEX(fAltInputText, groupStartIdx);
                 UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
+
+                //   Note: if the capture group match was of an empty string the backref
+                //         match succeeds.  Verified by testing:  Perl matches succeed 
+                //         in this case, so we do too.
                 
-                UBool haveMatch = (opType == URX_BACKREF ?
-                    (0 == utext_compareNativeLimit(fAltInputText, groupEndIdx, fInputText, -1)) :
-                    (0 == utext_caseCompareNativeLimit(fAltInputText, groupEndIdx, fInputText, -1, U_FOLD_CASE_DEFAULT, &status)));
-                fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                
-                if (fp->fInputIdx > fActiveLimit) {
-                    fHitEnd = TRUE;
-                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
-                } else if (!haveMatch) {
-                    if (fp->fInputIdx == fActiveLimit) {
+                UBool success = TRUE;
+                for (;;) {
+                    if (utext_getNativeIndex(fAltInputText) >= groupEndIdx) {
+                        success = TRUE;
+                        break;
+                    }
+                    if (utext_getNativeIndex(fInputText) >= fActiveLimit) {
+                        success = FALSE;
                         fHitEnd = TRUE;
+                        break;
                     }
+                    UChar32 captureGroupChar = utext_next32(fAltInputText);
+                    UChar32 inputChar = utext_next32(fInputText);
+                    if (inputChar != captureGroupChar) {
+                        success = FALSE;
+                        break;
+                    }
+                }
+
+                if (success) {
+                    fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
+                } else {
+                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
+                }
+            }
+            break;
+
+
+
+        case URX_BACKREF_I:
+            {
+                U_ASSERT(opValue < fFrameSize);
+                int64_t groupStartIdx = fp->fExtra[opValue];
+                int64_t groupEndIdx   = fp->fExtra[opValue+1];
+                U_ASSERT(groupStartIdx <= groupEndIdx);
+                if (groupStartIdx < 0) {
+                    // This capture group has not participated in the match thus far,
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
+                    break;
+                }
+                utext_setNativeIndex(fAltInputText, groupStartIdx);
+                utext_setNativeIndex(fInputText, fp->fInputIdx);
+                CaseFoldingUTextIterator captureGroupItr(*fAltInputText);
+                CaseFoldingUTextIterator inputItr(*fInputText);
+
+                //   Note: if the capture group match was of an empty string the backref
+                //         match succeeds.  Verified by testing:  Perl matches succeed 
+                //         in this case, so we do too.
+                
+                UBool success = TRUE;
+                for (;;) {
+                    if (!captureGroupItr.inExpansion() && utext_getNativeIndex(fAltInputText) >= groupEndIdx) {
+                        success = TRUE;
+                        break;
+                    }
+                    if (!inputItr.inExpansion() && utext_getNativeIndex(fInputText) >= fActiveLimit) {
+                        success = FALSE;
+                        fHitEnd = TRUE;
+                        break;
+                    }
+                    UChar32 captureGroupChar = captureGroupItr.next();
+                    UChar32 inputChar = inputItr.next();
+                    if (inputChar != captureGroupChar) {
+                        success = FALSE;
+                        break;
+                    }
+                }
+
+                if (success && inputItr.inExpansion()) {
+                    // We otained a match by consuming part of a string obtained from 
+                    // case-folding a single code point of the input text.  
+                    // This does not count as an overall match.
+                    success = FALSE;
+                }
+
+                if (success) {
+                    fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
+                } else {
+                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 }
+ 
             }
             break;
                 
@@ -3895,6 +3782,9 @@
             break;
 
         case URX_ONECHAR_I:
+            // Case insensitive one char.  The char from the pattern is already case folded.
+            // Input text is not, but case folding the input can not reduce two or more code
+            // points to one.
             if (fp->fInputIdx < fActiveLimit) {
                 UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
 
@@ -3907,148 +3797,53 @@
                 fHitEnd = TRUE;
             }
             
-            #ifdef REGEX_SMART_BACKTRACKING
-            if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                    UBool success = FALSE;
-                    UChar32 c = UTEXT_PREVIOUS32(fInputText);
-                    while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex) {
-                        if (u_foldCase(c, U_FOLD_CASE_DEFAULT) == opValue) {
-                            success = TRUE;
-                            break;
-                        } else if (c == U_SENTINEL) {
-                            break;
-                        }
-                        c = UTEXT_PREVIOUS32(fInputText);
-                    }
-                    if (success) {
-                        fHitEnd = FALSE;
-                        fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                        fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                        if (fp->fInputIdx > backSearchIndex) {
-                            fp = StateSave(fp, fp->fPatIdx, status);
-                        }
-                        fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                        break;
-                    }
-                }
-            }
-            #endif
-
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
 
         case URX_STRING_I:
             {
-                // Test input against a literal string.
+                // Case-insensitive test input against a literal string.
                 // Strings require two slots in the compiled pattern, one for the
                 //   offset to the string text, and one for the length.
-                const UCaseProps *csp = ucase_getSingleton();
+                //   The compiled string has already been case folded.
                 {
-                    int32_t stringStartIdx, stringLen;
-                    stringStartIdx = opValue;
+                    const UChar *patternString = litText + opValue;
+                    int32_t      patternStringIdx  = 0;
 
                     op      = (int32_t)pat[fp->fPatIdx];
                     fp->fPatIdx++;
                     opType  = URX_TYPE(op);
                     opValue = URX_VAL(op);
                     U_ASSERT(opType == URX_STRING_LEN);
-                    stringLen = opValue;
+                    int32_t patternStringLen = opValue;  // Length of the string from the pattern.
                 
-                    const UChar *patternChars = litText+stringStartIdx;
-                    const UChar *patternEnd = patternChars+stringLen;
-                    
-                    const UChar *foldChars = NULL;
-                    int32_t foldOffset, foldLength;
-                    UChar32 c;
-                    
-                    foldOffset = foldLength = 0;
-                    UBool success = TRUE;
                     
+                    UChar32   cPattern;
+                    UChar32   cText;
+                    UBool     success = TRUE;
+
                     UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
-                    while (patternChars < patternEnd && success) {
-                        if(foldOffset < foldLength) {
-                            U16_NEXT_UNSAFE(foldChars, foldOffset, c);
-                        } else {
-                            c = UTEXT_NEXT32(fInputText);
-                            if (c != U_SENTINEL) {
-                                foldLength = ucase_toFullFolding(csp, c, &foldChars, U_FOLD_CASE_DEFAULT);
-                                if(foldLength >= 0) {
-                                    if(foldLength <= UCASE_MAX_STRING_LENGTH) {   // !!!: Does not correctly handle chars that fold to 0-length strings
-                                        foldOffset = 0;
-                                        U16_NEXT_UNSAFE(foldChars, foldOffset, c);
-                                    } else {
-                                        c = foldLength;
-                                        foldLength = foldOffset; // to avoid reading chars from the folding buffer
-                                    }
-                                }
-                            }
-                            
-                            fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
+                    CaseFoldingUTextIterator inputIterator(*fInputText);
+                    while (patternStringIdx < patternStringLen) {
+                        if (!inputIterator.inExpansion() && UTEXT_GETNATIVEINDEX(fInputText) >= fActiveLimit) {
+                            success = FALSE;
+                            fHitEnd = TRUE;
+                            break;
                         }
-                        
-                        success = FALSE;
-                        if (c != U_SENTINEL && (fp->fInputIdx <= fActiveLimit)) {
-                            if (U_IS_BMP(c)) {
-                                success = (*patternChars == c);
-                                patternChars += 1;
-                            } else if (patternChars+1 < patternEnd) {
-                                success = (*patternChars == U16_LEAD(c) && *(patternChars+1) == U16_TRAIL(c));
-                                patternChars += 2;
-                            }
-                        } else {
-                            fHitEnd = TRUE;          //   TODO:  See ticket 6074
+                        U16_NEXT(patternString, patternStringIdx, patternStringLen, cPattern);
+                        cText = inputIterator.next();
+                        if (cText != cPattern) {
+                            success = FALSE;
+                            break;
                         }
                     }
-                    
-                    if (!success) {
-                        #ifdef REGEX_SMART_BACKTRACKING
-                        if (fp->fInputIdx > backSearchIndex && fStack->size()) {
-                            REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                            if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                                // Reset to last start point
-                                UTEXT_SETNATIVEINDEX(fInputText, fp->fInputIdx);
-                                patternChars = litText+stringStartIdx;
-                                
-                                // Search backwards for a possible start
-                                do {
-                                    c = UTEXT_PREVIOUS32(fInputText);
-                                    if (c == U_SENTINEL) {
-                                        break;
-                                    } else {
-                                        foldLength = ucase_toFullFolding(csp, c, &foldChars, U_FOLD_CASE_DEFAULT);
-                                        if(foldLength >= 0) {
-                                            if(foldLength <= UCASE_MAX_STRING_LENGTH) {   // !!!: Does not correctly handle chars that fold to 0-length strings
-                                                foldOffset = 0;
-                                                U16_NEXT_UNSAFE(foldChars, foldOffset, c);
-                                            } else {
-                                                c = foldLength;
-                                                foldLength = foldOffset; // to avoid reading chars from the folding buffer
-                                            }
-                                        }
-                                        
-                                        if ((U_IS_BMP(c) && *patternChars == c) ||
-                                               (*patternChars == U16_LEAD(c) && *(patternChars+1) == U16_TRAIL(c))) {
-                                            success = TRUE;
-                                            break;
-                                        }
-                                    }
-                                } while (UTEXT_GETNATIVEINDEX(fInputText) >= backSearchIndex);
-                                
-                                // And try again
-                                if (success) {
-                                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                                    fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
-                                    if (fp->fInputIdx > backSearchIndex) {
-                                        fp = StateSave(fp, fp->fPatIdx, status);
-                                    }
-                                    fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                                    break;
-                                }
-                            }
-                        }
-                        #endif
+                    if (inputIterator.inExpansion()) {
+                        success = FALSE;
+                    }
+
+                    if (success) {
+                        fp->fInputIdx = UTEXT_GETNATIVEINDEX(fInputText);
+                    } else {
                         fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                     }
                 }
@@ -4284,9 +4079,6 @@
                 int32_t stackLoc = URX_VAL(loopcOp);
                 U_ASSERT(stackLoc >= 0 && stackLoc < fFrameSize);
                 fp->fExtra[stackLoc] = fp->fInputIdx;
-                #ifdef REGEX_SMART_BACKTRACKING
-                backSearchIndex = fp->fInputIdx;
-                #endif
                 fp->fInputIdx = ix;
 
                 // Save State to the URX_LOOP_C op that follows this one,
@@ -4348,9 +4140,6 @@
                 int32_t stackLoc = URX_VAL(loopcOp);
                 U_ASSERT(stackLoc >= 0 && stackLoc < fFrameSize);
                 fp->fExtra[stackLoc] = fp->fInputIdx;
-                #ifdef REGEX_SMART_BACKTRACKING
-                backSearchIndex = fp->fInputIdx;
-                #endif
                 fp->fInputIdx = ix;
 
                 // Save State to the URX_LOOP_C op that follows this one,
@@ -4562,33 +4351,6 @@
             } else {
                 fHitEnd = TRUE;
             }
-
-            #ifdef REGEX_SMART_BACKTRACKING
-            if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                    int64_t reverseIndex = fp->fInputIdx;
-                    UChar32 c;
-                    do {
-                        U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                        if (c == opValue) {
-                            break;
-                        }
-                    } while (reverseIndex > backSearchIndex);
-                    if (c == opValue) {
-                        fHitEnd = FALSE;
-                        fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                        fp->fInputIdx = reverseIndex;
-                        if (fp->fInputIdx > backSearchIndex) {
-                            fp = StateSave(fp, fp->fPatIdx, status);
-                        }
-                        fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                        break;
-                    }
-                }
-            }
-            #endif
-
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
             
@@ -4608,28 +4370,19 @@
                 U_ASSERT(opType == URX_STRING_LEN);
                 U_ASSERT(stringLen >= 2);
                 
-                if (fp->fInputIdx + stringLen > fActiveLimit) {
-                    // No match.  String is longer than the remaining input text.
-                    fHitEnd = TRUE;          //   TODO:  See ticket 6074
-                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                    break;
-                }
-                
                 const UChar * pInp = inputBuf + fp->fInputIdx;
+                const UChar * pInpLimit = inputBuf + fActiveLimit;
                 const UChar * pPat = litText+stringStartIdx;
                 const UChar * pEnd = pInp + stringLen;
-                UBool success = FALSE;
-                for(;;) {
-                    if (*pInp == *pPat) {
-                        pInp++;
-                        pPat++;
-                        if (pInp == pEnd) {
-                            // Successful Match.
-                            success = TRUE;
-                            break;
-                        }
-                    } else {
-                        // Match failed.
+                UBool success = TRUE;
+                while (pInp < pEnd) {
+                    if (pInp >= pInpLimit) {
+                        fHitEnd = TRUE;
+                        success = FALSE;
+                        break;
+                    }
+                    if (*pInp++ != *pPat++) {
+                        success = FALSE;
                         break;
                     }
                 }
@@ -4637,38 +4390,6 @@
                 if (success) {
                     fp->fInputIdx += stringLen;
                 } else {
-                    #ifdef REGEX_SMART_BACKTRACKING
-                    if (fp->fInputIdx > backSearchIndex && fStack->size()) {
-                        REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                        if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                            // Reset to last start point
-                            int64_t reverseIndex = fp->fInputIdx;
-                            UChar32 c;
-                            pPat = litText+stringStartIdx;
-                            
-                            // Search backwards for a possible start
-                            do {
-                                U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                                if ((U_IS_BMP(c) && *pPat == c) ||
-                                    (*pPat == U16_LEAD(c) && *(pPat+1) == U16_TRAIL(c))) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            } while (reverseIndex > backSearchIndex);
-                            
-                            // And try again
-                            if (success) {
-                                fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                                fp->fInputIdx = reverseIndex;
-                                if (fp->fInputIdx > backSearchIndex) {
-                                    fp = StateSave(fp, fp->fPatIdx, status);
-                                }
-                                fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                                break;
-                            }
-                        }
-                    }
-                    #endif
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 }
             }
@@ -5038,41 +4759,6 @@
                     }
                 }
                 if (!success) {
-                    #ifdef REGEX_SMART_BACKTRACKING
-                    if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                        REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                        if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                            // Try to find it, backwards
-                            int64_t reverseIndex = fp->fInputIdx;
-                            U16_BACK_1(inputBuf, backSearchIndex, reverseIndex); // skip the first character we tried
-                            success = ((opValue & URX_NEG_SET) == URX_NEG_SET); // reset
-                            do {
-                                U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                                if (c < 256) {
-                                    Regex8BitSet *s8 = &fPattern->fStaticSets8[opValue];
-                                    if (s8->contains(c)) {
-                                        success = !success;
-                                    }
-                                } else {
-                                    const UnicodeSet *s = fPattern->fStaticSets[opValue];
-                                    if (s->contains(c)) {
-                                        success = !success;
-                                    }
-                                }
-                            } while (reverseIndex > backSearchIndex && !success);
-                            
-                            if (success) {
-                                fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                                fp->fInputIdx = reverseIndex;
-                                if (fp->fInputIdx > backSearchIndex) {
-                                    fp = StateSave(fp, fp->fPatIdx, status);
-                                }
-                                fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                                break;
-                            }
-                        }
-                    }
-                    #endif
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 }
             }
@@ -5104,44 +4790,6 @@
                         break;
                     }
                 }
-
-                #ifdef REGEX_SMART_BACKTRACKING
-                if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                    REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                    if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                        // Try to find it, backwards
-                        int64_t reverseIndex = fp->fInputIdx;
-                        U16_BACK_1(inputBuf, backSearchIndex, reverseIndex); // skip the first character we tried
-                        UBool success = FALSE;
-                        do {
-                            U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                            if (c < 256) {
-                                Regex8BitSet *s8 = &fPattern->fStaticSets8[opValue];
-                                if (s8->contains(c) == FALSE) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            } else {
-                                const UnicodeSet *s = fPattern->fStaticSets[opValue];
-                                if (s->contains(c) == FALSE) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            }
-                        } while (reverseIndex > backSearchIndex);
-                        
-                        if (success) {
-                            fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                            fp->fInputIdx = reverseIndex;
-                            if (fp->fInputIdx > backSearchIndex) {
-                                fp = StateSave(fp, fp->fPatIdx, status);
-                            }
-                            fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                            break;
-                        }
-                    }
-                }
-                #endif
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             }
             break;
@@ -5175,43 +4823,6 @@
                 }
                 
                 // the character wasn't in the set.
-                #ifdef REGEX_SMART_BACKTRACKING
-                if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                    REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                    if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                        // Try to find it, backwards
-                        int64_t reverseIndex = fp->fInputIdx;
-                        U16_BACK_1(inputBuf, backSearchIndex, reverseIndex); // skip the first character we tried
-                        UBool success = FALSE;
-                        do {
-                            U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                            if (c < 256) {
-                                Regex8BitSet *s8 = &fPattern->fSets8[opValue];
-                                if (s8->contains(c)) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            } else {
-                                UnicodeSet *s = (UnicodeSet *)sets->elementAt(opValue);
-                                if (s->contains(c)) {
-                                    success = TRUE;
-                                    break;
-                                }
-                            }
-                        } while (reverseIndex > backSearchIndex);
-                        
-                        if (success) {
-                            fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                            fp->fInputIdx = reverseIndex;
-                            if (fp->fInputIdx > reverseIndex) {
-                                fp = StateSave(fp, fp->fPatIdx, status);
-                            }
-                            fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                            break;
-                        }
-                    }
-                }
-                #endif
                 fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             }
             break;
@@ -5464,50 +5075,89 @@
             break;
             
         case URX_BACKREF:
+            {
+                U_ASSERT(opValue < fFrameSize);
+                int64_t groupStartIdx = fp->fExtra[opValue];
+                int64_t groupEndIdx   = fp->fExtra[opValue+1];
+                U_ASSERT(groupStartIdx <= groupEndIdx);
+                int64_t inputIndex = fp->fInputIdx;
+                if (groupStartIdx < 0) {
+                    // This capture group has not participated in the match thus far,
+                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
+                    break;
+                }
+                UBool success = TRUE;
+                for (int64_t groupIndex = groupStartIdx; groupIndex < groupEndIdx; ++groupIndex,++inputIndex) {
+                    if (inputIndex >= fActiveLimit) {
+                        success = FALSE;
+                        fHitEnd = TRUE;
+                        break;
+                    }
+                    if (inputBuf[groupIndex] != inputBuf[inputIndex]) {
+                        success = FALSE;
+                        break;
+                    }
+                }
+                if (success) {
+                    fp->fInputIdx = inputIndex;
+                } else {
+                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
+                }
+            }
+            break;
+            
         case URX_BACKREF_I:
             {
                 U_ASSERT(opValue < fFrameSize);
                 int64_t groupStartIdx = fp->fExtra[opValue];
                 int64_t groupEndIdx   = fp->fExtra[opValue+1];
                 U_ASSERT(groupStartIdx <= groupEndIdx);
-                int64_t len = groupEndIdx-groupStartIdx;
                 if (groupStartIdx < 0) {
                     // This capture group has not participated in the match thus far,
                     fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
+                    break;
                 }
+                CaseFoldingUCharIterator captureGroupItr(inputBuf, groupStartIdx, groupEndIdx);
+                CaseFoldingUCharIterator inputItr(inputBuf, fp->fInputIdx, fActiveLimit);
 
-                if (len == 0) {
-                        //   The capture group match was of an empty string.
-                        //   Verified by testing:  Perl matches succeed in this case, so
-                        //   we do too.
+                //   Note: if the capture group match was of an empty string the backref
+                //         match succeeds.  Verified by testing:  Perl matches succeed 
+                //         in this case, so we do too.
+                
+                UBool success = TRUE;
+                for (;;) {
+                    UChar32 captureGroupChar = captureGroupItr.next();
+                    if (captureGroupChar == U_SENTINEL) {
+                        success = TRUE;
                         break;
                     }
-
-                UBool  haveMatch = FALSE;
-                if (fp->fInputIdx + len <= fActiveLimit) {
-                    if (opType == URX_BACKREF) {
-                        if (u_strncmp(inputBuf+groupStartIdx, inputBuf+fp->fInputIdx, (int32_t)len) == 0) {
-                            haveMatch = TRUE;
-                        }
-                    } else {
-                        if (u_strncasecmp(inputBuf+groupStartIdx, inputBuf+fp->fInputIdx,
-                                  (int32_t)len, U_FOLD_CASE_DEFAULT) == 0) {
-                            haveMatch = TRUE;
-                        }
+                    UChar32 inputChar = inputItr.next();
+                    if (inputChar == U_SENTINEL) {
+                        success = FALSE;
+                        fHitEnd = TRUE;
+                        break;
                     }
-                } else {
-                    // TODO: probably need to do a partial string comparison, and only
-                    //       set HitEnd if the available input matched.  Ticket #6074
-                    fHitEnd = TRUE;
+                    if (inputChar != captureGroupChar) {
+                        success = FALSE;
+                        break;
+                    }
+                }
+
+                if (success && inputItr.inExpansion()) {
+                    // We otained a match by consuming part of a string obtained from 
+                    // case-folding a single code point of the input text.  
+                    // This does not count as an overall match.
+                    success = FALSE;
                 }
-                if (haveMatch) {
-                    fp->fInputIdx += len;     // Match.  Advance current input position.
+
+                if (success) {
+                    fp->fInputIdx = inputItr.getIndex();
                 } else {
-                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);   // FAIL, no match.
+                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
                 }
             }
             break;
-            
+
         case URX_STO_INP_LOC:
             {
                 U_ASSERT(opValue >= 0 && opValue < fFrameSize);
@@ -5582,160 +5232,52 @@
             } else {
                 fHitEnd = TRUE;
             }
-            
-            #ifdef REGEX_SMART_BACKTRACKING
-            if (fp->fInputIdx > backSearchIndex && fStack->size() > fFrameSize) {
-                REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                    UBool success = FALSE;
-                    int64_t reverseIndex = fp->fInputIdx;
-                    UChar32 c;
-                    while (reverseIndex > backSearchIndex) {
-                        U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                        if (u_foldCase(c, U_FOLD_CASE_DEFAULT) == opValue) {
-                            success = TRUE;
-                            break;
-                        } else if (c == U_SENTINEL) {
-                            break;
-                        }
-                    }
-                    if (success) {
-                        fHitEnd = FALSE;
-                        fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                        fp->fInputIdx = reverseIndex;
-                        if (fp->fInputIdx > backSearchIndex) {
-                            fp = StateSave(fp, fp->fPatIdx, status);
-                        }
-                        fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                        break;
-                    }
-                }
-            }
-            #endif
-
             fp = (REStackFrame *)fStack->popFrame(fFrameSize);
             break;
             
         case URX_STRING_I:
+            // Case-insensitive test input against a literal string.
+            // Strings require two slots in the compiled pattern, one for the
+            //   offset to the string text, and one for the length.
+            //   The compiled string has already been case folded.
             {
-                // Test input against a literal string.
-                // Strings require two slots in the compiled pattern, one for the
-                //   offset to the string text, and one for the length.
-                const UCaseProps *csp = ucase_getSingleton();
-                {
-                    int32_t stringStartIdx, stringLen;
-                    stringStartIdx = opValue;
-                    
-                    op      = (int32_t)pat[fp->fPatIdx];
-                    fp->fPatIdx++;
-                    opType  = URX_TYPE(op);
-                    opValue = URX_VAL(op);
-                    U_ASSERT(opType == URX_STRING_LEN);
-                    stringLen = opValue;
-                    
-                    const UChar *patternChars = litText+stringStartIdx;
-                    const UChar *patternEnd = patternChars+stringLen;
-                    
-                    const UChar *foldChars = NULL;
-                    int32_t foldOffset, foldLength;
-                    UChar32 c;
-                    UBool c_is_valid = FALSE;
-                    
-                    #ifdef REGEX_SMART_BACKTRACKING
-                    int32_t originalInputIdx = fp->fInputIdx;
-                    #endif
-                    UBool success = TRUE;
-                    
-                    foldOffset = foldLength = 0;
+                const UChar *patternString = litText + opValue;
 
-                    while (patternChars < patternEnd && success) {
-                        if (fp->fInputIdx < fActiveLimit) {  // don't read past end of string
-                            if(foldOffset < foldLength) {
-                                U16_NEXT_UNSAFE(foldChars, foldOffset, c);
-                                c_is_valid = TRUE;
-                            } else {
-                                // test pre-condition of U16_NEXT: i < length
-                                U_ASSERT(fp->fInputIdx < fActiveLimit);
-                                U16_NEXT(inputBuf, fp->fInputIdx, fActiveLimit, c);
-                                c_is_valid = TRUE;
-                                foldLength = ucase_toFullFolding(csp, c, &foldChars, U_FOLD_CASE_DEFAULT);
-                                if(foldLength >= 0) {
-                                    if(foldLength <= UCASE_MAX_STRING_LENGTH) {   // !!!: Does not correctly handle chars that fold to 0-length strings
-                                        foldOffset = 0;
-                                        U16_NEXT_UNSAFE(foldChars, foldOffset, c);
-                                    } else {
-                                        c = foldLength;
-                                        foldLength = foldOffset; // to avoid reading chars from the folding buffer
-                                    }
-                                }
-                            }
-                        } else {
-                          c_is_valid = FALSE;
-                        }
-                        
-                        if (fp->fInputIdx <= fActiveLimit && c_is_valid) {
-                            if (U_IS_BMP(c)) {
-                                success = (*patternChars == c);
-                                patternChars += 1;
-                            } else if (patternChars+1 < patternEnd) {
-                                success = (*patternChars == U16_LEAD(c) && *(patternChars+1) == U16_TRAIL(c));
-                                patternChars += 2;
-                            }
-                        } else {
-                            success = FALSE;
-                            fHitEnd = TRUE;          //   TODO:  See ticket 6074
-                        }
-                    }
-                    
-                    if (!success) {
-                        #ifdef REGEX_SMART_BACKTRACKING
-                        if (fp->fInputIdx > backSearchIndex && fStack->size()) {
-                            REStackFrame *prevFrame = (REStackFrame *)fStack->peekFrame(fFrameSize);
-                            if (URX_LOOP_C == URX_TYPE(pat[prevFrame->fPatIdx]) && fp->fInputIdx <= prevFrame->fInputIdx) {
-                                // Reset to last start point
-                                int64_t reverseIndex = originalInputIdx;
-                                patternChars = litText+stringStartIdx;
-                                
-                                // Search backwards for a possible start
-                                do {
-                                    U16_PREV(inputBuf, backSearchIndex, reverseIndex, c);
-                                    foldLength = ucase_toFullFolding(csp, c, &foldChars, U_FOLD_CASE_DEFAULT);
-                                    if(foldLength >= 0) {
-                                        if(foldLength <= UCASE_MAX_STRING_LENGTH) {   // !!!: Does not correctly handle chars that fold to 0-length strings
-                                            foldOffset = 0;
-                                            U16_NEXT_UNSAFE(foldChars, foldOffset, c);
-                                        } else {
-                                            c = foldLength;
-                                            foldLength = foldOffset; // to avoid reading chars from the folding buffer
-                                        }
-                                    }
-                                    
-                                    if ((U_IS_BMP(c) && *patternChars == c) ||
-                                           (*patternChars == U16_LEAD(c) && *(patternChars+1) == U16_TRAIL(c))) {
-                                        success = TRUE;
-                                        break;
-                                    }
-                                } while (reverseIndex > backSearchIndex);
-                                
-                                // And try again
-                                if (success) {
-                                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
-                                    fp->fInputIdx = reverseIndex;
-                                    if (fp->fInputIdx > backSearchIndex) {
-                                        fp = StateSave(fp, fp->fPatIdx, status);
-                                    }
-                                    fp->fPatIdx++; // Skip the LOOP_C, we just did that
-                                    break;
-                                }
-                            }
+                op      = (int32_t)pat[fp->fPatIdx];
+                fp->fPatIdx++;
+                opType  = URX_TYPE(op);
+                opValue = URX_VAL(op);
+                U_ASSERT(opType == URX_STRING_LEN);
+                int32_t patternStringLen = opValue;  // Length of the string from the pattern.
+            
+                UChar32      cText;
+                UChar32      cPattern;
+                UBool        success = TRUE;
+                int32_t      patternStringIdx  = 0;
+                CaseFoldingUCharIterator inputIterator(inputBuf, fp->fInputIdx, fActiveLimit);
+                while (patternStringIdx < patternStringLen) {
+                    U16_NEXT(patternString, patternStringIdx, patternStringLen, cPattern);
+                    cText = inputIterator.next();
+                    if (cText != cPattern) {
+                        success = FALSE;
+                        if (cText == U_SENTINEL) {
+                            fHitEnd = TRUE;
                         }
-                        #endif
-                        fp = (REStackFrame *)fStack->popFrame(fFrameSize);
+                        break;
                     }
                 }
+                if (inputIterator.inExpansion()) {
+                    success = FALSE;
+                }
+
+                if (success) {
+                    fp->fInputIdx = inputIterator.getIndex();
+                } else {
+                    fp = (REStackFrame *)fStack->popFrame(fFrameSize);
+                }
             }
             break;
-            
+
         case URX_LB_START:
             {
                 // Entering a look-behind block.
@@ -5962,9 +5504,6 @@
                 int32_t stackLoc = URX_VAL(loopcOp);
                 U_ASSERT(stackLoc >= 0 && stackLoc < fFrameSize);
                 fp->fExtra[stackLoc] = fp->fInputIdx;
-                #ifdef REGEX_SMART_BACKTRACKING
-                backSearchIndex = fp->fInputIdx;
-                #endif
                 fp->fInputIdx = ix;
                 
                 // Save State to the URX_LOOP_C op that follows this one,
@@ -6027,9 +5566,6 @@
                 int32_t stackLoc = URX_VAL(loopcOp);
                 U_ASSERT(stackLoc >= 0 && stackLoc < fFrameSize);
                 fp->fExtra[stackLoc] = fp->fInputIdx;
-                #ifdef REGEX_SMART_BACKTRACKING
-                backSearchIndex = fp->fInputIdx;
-                #endif
                 fp->fInputIdx = ix;
                 
                 // Save State to the URX_LOOP_C op that follows this one,
Index: icu-4.8.1.1/source/i18n/unicode/regex.h
===================================================================
--- icu-4.8.1.1.orig/source/i18n/unicode/regex.h	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/i18n/unicode/regex.h	2015-03-02 08:20:03.449220931 -0500
@@ -53,24 +53,20 @@
 
 #include "unicode/uregex.h"
 
-U_NAMESPACE_BEGIN
-
+// Forward Declarations
 
-// Forward Declarations...
+U_NAMESPACE_BEGIN
 
-class RegexMatcher;
-class RegexPattern;
-class UVector;
-class UVector32;
-class UVector64;
-class UnicodeSet;
-struct REStackFrame;
 struct Regex8BitSet;
-class  RuleBasedBreakIterator;
 class  RegexCImpl;
-
-
-
+class  RegexMatcher;
+class  RegexPattern;
+struct REStackFrame;
+class  RuleBasedBreakIterator;
+class  UnicodeSet;
+class  UVector;
+class  UVector32;
+class  UVector64;
 
 /**
  *   RBBIPatternDump   Debug function, displays the compiled form of a pattern.
@@ -1310,9 +1306,9 @@
 
 
     /**
-      * Return TRUE if the most recent matching operation touched the
-      *  end of the text being processed.  In this case, additional input text could
-      *  change the results of that match.
+      * Return TRUE if the most recent matching operation attempted to access
+      *  additional input beyond the available input text.
+      *  In this case, additional input text could change the results of the match.
       *
       *  hitEnd() is defined for both successful and unsuccessful matches.
       *  In either case hitEnd() will return TRUE if if the end of the text was
@@ -1852,8 +1848,6 @@
                                            //   reported, or that permanently disables this matcher.
 
     RuleBasedBreakIterator  *fWordBreakItr;
-
-
 };
 
 U_NAMESPACE_END
Index: icu-4.8.1.1/source/test/testdata/regextst.txt
===================================================================
--- icu-4.8.1.1.orig/source/test/testdata/regextst.txt	2015-03-02 08:20:03.453220963 -0500
+++ icu-4.8.1.1/source/test/testdata/regextst.txt	2015-03-02 08:20:03.449220931 -0500
@@ -13,8 +13,8 @@
 #               <tagged string> = text, with the start and end of each
 #                                 capture group tagged with <n>...</n>.  The overall match,
 #                                 if any, is group 0, as in <0>matched text</0>
-#
 #                                  A region can be specified with <r>...</r> tags.
+#                                 Standard ICU unescape will be applied, allowing \u, \U, etc. to appear.
 #
 #               <flags>         = any combination of
 #                                   i      case insensitive match
@@ -117,6 +117,24 @@
 "xyz$"                  yz     "<0>xyz</0>"
 
 #
+#  HitEnd 
+#
+"abcd"                  Lz      "a"
+"abcd"                  Lz      "ab"
+"abcd"                  Lz      "abc"
+"abcd"                  LZ      "<0>abcd</0>"
+"abcd"                  LZ      "<0>abcd</0>e"
+"abcd"                  LZ      "abcx"
+"abcd"                  LZ      "abx"
+"abcd"                  Lzi     "a"
+"abcd"                  Lzi     "ab"
+"abcd"                  Lzi     "abc"
+"abcd"                  LZi     "<0>abcd</0>"
+"abcd"                  LZi     "<0>abcd</0>e"
+"abcd"                  LZi     "abcx"
+"abcd"                  LZi     "abx"
+
+#
 #  All Unicode line endings recognized.
 #     0a, 0b, 0c, 0d, 0x85, 0x2028, 0x2029
 #     Multi-line and non-multiline mode take different paths, so repeated tests.
@@ -176,6 +194,7 @@
 "(hello)|(goodbye)"            "<0><2>goodbye</2></0>"
 "abc( +(  inner(X?) +)  xyz)"  "leading cruft <0>abc<1>     <2>  inner<3></3>    </2>  xyz</1></0> cruft"
 "\s*([ixsmdt]*)([:letter:]*)"  "<0>   <1>d</1><2></2></0>  "
+"(a|b)c*d"                     "a<0><1>b</1>cd</0>"
 
 # Non-capturing parens (?: stuff).   Groups, but does not capture.
 "(?:abc)*(tail)"               "<0>abcabcabc<1>tail</1></0>"
@@ -452,6 +471,40 @@
 "ab(?:c|(d?))(\1)"             "<0>ab<1></1><2></2></0>e"
 "ab(?:c|(d?))(\1)"             "<0>ab<1></1><2></2></0>"
 
+# Back References that hit/don't hit end
+"(abcd) \1"                z   "abcd abc"
+"(abcd) \1"                Z   "<0><1>abcd</1> abcd</0>"
+"(abcd) \1"                Z   "<0><1>abcd</1> abcd</0> "
+
+# Case Insensitve back references that hit/don't hit end.
+"(abcd) \1"                zi  "abcd abc"
+"(abcd) \1"                Zi  "<0><1>abcd</1> ABCD</0>"
+"(abcd) \1"                Zi  "<0><1>abcd</1> ABCD</0> "
+
+# Back references that hit/don't hit boundary limits.
+
+"(abcd) \1"                z   "<r>abcd abc</r>d "
+"(abcd) \1"                Z   "<r><0><1>abcd</1> abcd</0></r> "
+"(abcd) \1"                Z   "<r><0><1>abcd</1> abcd</0> </r>"
+
+"(abcd) \1"                zi  "<r>abcd abc</r>d "
+"(abcd) \1"                Zi  "<r><0><1>abcd</1> abcd</0></r> "
+"(abcd) \1"                Zi  "<r><0><1>abcd</1> abcd</0> </r>"
+
+# Back reference that fails match near the end of input without actually hitting the end.
+"(abcd) \1"                ZL  "abcd abd"
+"(abcd) \1"                ZLi "abcd abd"
+
+# Back reference to a zero-length match.  They are always a successful match.
+"ab(x?)cd(\1)ef"               "<0>ab<1></1>cd<2></2>ef</0>"
+"ab(x?)cd(\1)ef"            i  "<0>ab<1></1>cd<2></2>ef</0>"
+
+# Back refs to capture groups that didn't participate in the match.
+"ab(?:(c)|(d))\1"              "abde"
+"ab(?:(c)|(d))\1"              "<0>ab<1>c</1>c</0>e"
+"ab(?:(c)|(d))\1"            i "abde"
+"ab(?:(c)|(d))\1"            i "<0>ab<1>c</1>c</0>e"
+
 # Case Insensitive
 "aBc"                    i      "<0>ABC</0>"
 "a[^bc]d"                i      "ABD"
@@ -602,6 +655,7 @@
 "\ud800\udc00*"                   "<0>\U00010000\U00010000\U00010000</0>\U00010001"
 "\ud800\ud800\udc00"              "<0>\ud800\U00010000</0>\U00010000\U00010000\U00010001"
 "(\ud800)(\udc00)"                "\U00010000"
+"\U00010001+"                     "<0>\U00010001\U00010001</0>\udc01"
 
 #
 # hitEnd with find()
@@ -1030,6 +1084,41 @@
 #
 "((.??)+|A)*"                     "<0><1><2></2></1></0>AAAAABBBBBCCCCCDDDDEEEEE"
 
+#
+#    Bug 8826.  Incorrect results with case insensitive matches.
+#
+"AS(X)"                         i "aßx"
+"AS.*"                          i "aßx"           # Expansion of sharp s can't split between pattern terms.
+"ASßS"                          i "<0>aßß</0>"    # All one literal string, does match.
+"ASß{1}S"                       i "aßß"           # Pattern with terms, no match.
+"aßx"                           i "<0>assx</0>"
+"aßx"                           i "<0>ASSX</0>"
+"aßx"                           i "<0>aßx</0>"
+"ASS(.)"                        i "<0>aß<1>x</1></0>"
+
+# Case Insensitive, probe some corner cases.
+"ass+"                          i "aß"            # Second 's' in pattern is qualified, can't combine with first.
+"as+"                           i "aß"
+"aßs"                           i "as"            # Can't match half of a ß
+"aß+"                           i "<0>assssssss</0>s"
+"aß+"                           i "<0>assßSssSSS</0>s"
+"a(ß?)+"                        i "<0>assssssss<1></1></0>s"
+"a(ß?)+"                        i "<0>a<1></1></0>zzzzzzzzs"
+
+"\U00010400"                    i "<0>\U00010428</0>"   # case folded supplemental code point.
+
+"sstuff"                        i "<0>ßtuff</0>"    # exercise optimizations on what chars can start a match.
+"sstuff"                        i "s<0>ßtuff</0>"    # exercise optimizations on what chars can start a match.
+"ßtuff"                         i "s<0>sstuff</0>"
+"ßtuff"                         i "s<0>Sstuff</0>"
+
+"a(..)\1"                       i "<0>A<1>bc</1>BC</0>def"
+"(ß)\1"                         i "aa<0><1>ss</1>ß</0>zz"          # Case insensitive back reference
+"..(.)\1"                       i "<0>aa<1>ß</1>ss</0>"
+"ab(..)\1"                      i "xx<0>ab<1>ss</1>ß</0>ss" 
+
+" (ss) ((\1.*)|(.*))"           i "<0> <1>ss</1> <2><4>sß</4></2></0>"       # The back reference 'ss' must not match in 'sß'
+
 #  Random debugging, Temporary
 #
 #"^(?:a?b?)*$"	                  "a--"
